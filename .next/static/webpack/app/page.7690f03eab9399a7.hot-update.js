"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.js":
/*!*********************!*\
  !*** ./app/page.js ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _page_module_scss__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./page.module.scss */ \"(app-pages-browser)/./app/page.module.scss\");\n/* harmony import */ var _page_module_scss__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_page_module_scss__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var _utils_MousePositionContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/MousePositionContext */ \"(app-pages-browser)/./app/utils/MousePositionContext.js\");\n/* harmony import */ var _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @studio-freight/lenis */ \"(app-pages-browser)/./node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_loadingpage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/loadingpage */ \"(app-pages-browser)/./app/components/loadingpage/index.js\");\n/* harmony import */ var _components_xmass_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/xmass_tree */ \"(app-pages-browser)/./app/components/xmass_tree/index.js\");\n/* harmony import */ var _components_intro__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/intro */ \"(app-pages-browser)/./app/components/intro/index.js\");\n/* harmony import */ var _components_wedonate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/wedonate */ \"(app-pages-browser)/./app/components/wedonate/index.js\");\n/* harmony import */ var _components_video__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/video */ \"(app-pages-browser)/./app/components/video/index.js\");\n/* harmony import */ var _components_merryXmass__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/merryXmass */ \"(app-pages-browser)/./app/components/merryXmass/index.js\");\n/* harmony import */ var _components_wishes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/wishes */ \"(app-pages-browser)/./app/components/wishes/index.js\");\n/* harmony import */ var _components_audio_icon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/audio_icon */ \"(app-pages-browser)/./app/components/audio_icon/index.js\");\n/* harmony import */ var _components_footer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/footer */ \"(app-pages-browser)/./app/components/footer/index.js\");\n/* harmony import */ var _components_header__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/header */ \"(app-pages-browser)/./app/components/header/index.js\");\n/* harmony import */ var _components_headerInit__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/headerInit */ \"(app-pages-browser)/./app/components/headerInit/index.js\");\n/* harmony import */ var _utils_sources__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/sources */ \"(app-pages-browser)/./app/utils/sources.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"(app-pages-browser)/./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_SVGLoader__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! three/examples/jsm/loaders/SVGLoader */ \"(app-pages-browser)/./node_modules/three/examples/jsm/loaders/SVGLoader.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Home() {\n    _s();\n    const [isLoaded, setIsLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [start, setStart] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [audio, setAudio] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    const [santaModel, setSantaModel] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    const [treeModel, setTreeModel] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    const [merryText, setMerryText] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    const [starTexture, setStarTexture] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    let loaders;\n    let toLoad;\n    let items = {};\n    let loaded = 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        toLoad = _utils_sources__WEBPACK_IMPORTED_MODULE_14__[\"default\"].length;\n        setLoaders();\n        startLoading(_utils_sources__WEBPACK_IMPORTED_MODULE_14__[\"default\"]);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const lenis = new _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_15__[\"default\"]();\n        const raf = (time)=>{\n            lenis.raf(time);\n            requestAnimationFrame(raf);\n        };\n        requestAnimationFrame(raf);\n    }, []);\n    const setLoaders = ()=>{\n        loaders = {};\n        loaders.gltfLoader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_16__.GLTFLoader();\n        loaders.textureLoader = new three__WEBPACK_IMPORTED_MODULE_17__.TextureLoader();\n        loaders.svgLoader = new three_examples_jsm_loaders_SVGLoader__WEBPACK_IMPORTED_MODULE_18__.SVGLoader();\n    };\n    const startLoading = (allSources)=>{\n        for (const source of allSources){\n            if (source.type === \"gltfModel\") {\n                loaders.gltfLoader.load(source.path, (model)=>{\n                    if (source.name === \"santaclaus\") {\n                        setSantaModel(model);\n                    }\n                    if (source.name === \"tree\") {\n                        setTreeModel(model);\n                    }\n                    sourceLoaded(source, model);\n                });\n            } else if (source.type === \"textureModel\") {\n                loaders.textureLoader.load(source.path, (texture)=>{\n                    if (source.name === \"merryChristmas\") {\n                        setMerryText(texture);\n                    }\n                    if (source.name === \"star\") {\n                        setStarTexture(texture);\n                    }\n                    sourceLoaded(source, texture);\n                });\n            } else if (source.type === \"svgModel\") {\n                loaders.svgLoader.load(source.path, (svg)=>{\n                    console.log(svg);\n                });\n            }\n        }\n    };\n    const sourceLoaded = (source, file)=>{\n        items[source.name] = file;\n        loaded++;\n        if (loaded === toLoad) {\n            console.log(\"** READY **\");\n            setIsLoaded(true);\n        }\n    };\n    const receiveDataFromButton = (data)=>{\n        setStart(data);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: (_page_module_scss__WEBPACK_IMPORTED_MODULE_19___default().main),\n        children: [\n            !start && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_headerInit__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                        lineNumber: 116,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_loadingpage__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        tree: treeModel,\n                        showbtn: isLoaded,\n                        sendDataToParent: receiveDataFromButton\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                        lineNumber: 117,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_utils_MousePositionContext__WEBPACK_IMPORTED_MODULE_1__.MousePositionProvider, {\n                children: [\n                    treeModel && starTexture && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_xmass_tree__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        tree: treeModel,\n                        starTexture: starTexture,\n                        start: start\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                        lineNumber: 123,\n                        columnNumber: 13\n                    }, this),\n                    start && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_header__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 129,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_intro__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 130,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_wedonate__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                santa: santaModel\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 131,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_video__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 132,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_merryXmass__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                texture: merryText\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 133,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_wishes__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 134,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_audio_icon__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 135,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_footer__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {}, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                                lineNumber: 136,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n                lineNumber: 120,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\jordi\\\\Documents\\\\00_Projectes\\\\00_Respublica\\\\Respublica\\\\app\\\\page.js\",\n        lineNumber: 113,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"e1IjDOLGNyHdR1cd30MMnusNn54=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFdUM7QUFFNkI7QUFFM0I7QUFDRTtBQUNPO0FBQ0g7QUFDVDtBQUNNO0FBQ047QUFDVztBQUNUO0FBQ087QUFDUDtBQUVBO0FBQ1E7QUFFVjtBQUVEO0FBQzZCO0FBQ0Q7QUFHbEQsU0FBU29COztJQUV0QixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR2xCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ21CLE9BQU9DLFNBQVMsR0FBR3BCLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ3FCLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQTtJQUVsQyxNQUFNLENBQUN1QixZQUFZQyxjQUFjLEdBQUd4QiwrQ0FBUUE7SUFDNUMsTUFBTSxDQUFDeUIsV0FBV0MsYUFBYSxHQUFHMUIsK0NBQVFBO0lBQzFDLE1BQU0sQ0FBQzJCLFdBQVdDLGFBQWEsR0FBRzVCLCtDQUFRQTtJQUMxQyxNQUFNLENBQUM2QixhQUFhQyxlQUFlLEdBQUc5QiwrQ0FBUUE7SUFFOUMsSUFBSStCO0lBQ0osSUFBSUM7SUFDSixJQUFJQyxRQUFRLENBQUM7SUFDYixJQUFJQyxTQUFTO0lBRWJuQyxnREFBU0EsQ0FBQztRQUNSaUMsU0FBU3BCLHVEQUFPQSxDQUFDdUIsTUFBTTtRQUN2QkM7UUFDQUMsYUFBYXpCLHVEQUFPQTtJQUN0QixHQUFHLEVBQUU7SUFFTGIsZ0RBQVNBLENBQUM7UUFDUixNQUFNdUMsUUFBUSxJQUFJeEMsOERBQUtBO1FBQ3ZCLE1BQU15QyxNQUFNLENBQUNDO1lBQ1hGLE1BQU1DLEdBQUcsQ0FBQ0M7WUFDVkMsc0JBQXNCRjtRQUN4QjtRQUNBRSxzQkFBc0JGO0lBQ3hCLEdBQUcsRUFBRTtJQUVMLE1BQU1ILGFBQWE7UUFDakJMLFVBQVUsQ0FBQztRQUNYQSxRQUFRVyxVQUFVLEdBQUcsSUFBSTVCLDhFQUFVQTtRQUNuQ2lCLFFBQVFZLGFBQWEsR0FBRyxJQUFJOUIsaURBQWFBO1FBQ3pDa0IsUUFBUWEsU0FBUyxHQUFHLElBQUk3Qiw0RUFBU0E7SUFDbkM7SUFFQSxNQUFNc0IsZUFBZSxDQUFDUTtRQUVwQixLQUFLLE1BQU1DLFVBQVVELFdBQVk7WUFDN0IsSUFBSUMsT0FBT0MsSUFBSSxLQUFLLGFBQWE7Z0JBQy9CaEIsUUFBUVcsVUFBVSxDQUFDTSxJQUFJLENBQUNGLE9BQU9HLElBQUksRUFBRSxDQUFDQztvQkFDcEMsSUFBSUosT0FBT0ssSUFBSSxLQUFLLGNBQWM7d0JBQ2hDM0IsY0FBYzBCO29CQUNoQjtvQkFFQSxJQUFJSixPQUFPSyxJQUFJLEtBQUssUUFBUTt3QkFDMUJ6QixhQUFhd0I7b0JBQ2Y7b0JBQ0FFLGFBQWFOLFFBQVFJO2dCQUN2QjtZQUNGLE9BQU8sSUFBSUosT0FBT0MsSUFBSSxLQUFLLGdCQUFnQjtnQkFDekNoQixRQUFRWSxhQUFhLENBQUNLLElBQUksQ0FBQ0YsT0FBT0csSUFBSSxFQUFFLENBQUNJO29CQUN2QyxJQUFJUCxPQUFPSyxJQUFJLEtBQUssa0JBQWtCO3dCQUNwQ3ZCLGFBQWF5QjtvQkFDZjtvQkFDQSxJQUFJUCxPQUFPSyxJQUFJLEtBQUssUUFBUTt3QkFDMUJyQixlQUFldUI7b0JBQ2pCO29CQUNBRCxhQUFhTixRQUFRTztnQkFDdkI7WUFDRixPQUFPLElBQUlQLE9BQU9DLElBQUksS0FBSyxZQUFZO2dCQUNyQ2hCLFFBQVFhLFNBQVMsQ0FBQ0ksSUFBSSxDQUFDRixPQUFPRyxJQUFJLEVBQUUsQ0FBQ0s7b0JBQ25DQyxRQUFRQyxHQUFHLENBQUNGO2dCQUNkO1lBQ0Y7UUFDSjtJQUNGO0lBRUEsTUFBTUYsZUFBZSxDQUFDTixRQUFRVztRQUM1QnhCLEtBQUssQ0FBQ2EsT0FBT0ssSUFBSSxDQUFDLEdBQUdNO1FBQ3JCdkI7UUFDQSxJQUFJQSxXQUFXRixRQUFRO1lBQ3JCdUIsUUFBUUMsR0FBRyxDQUFDO1lBQ1p0QyxZQUFZO1FBQ2Q7SUFDRjtJQUVBLE1BQU13Qyx3QkFBd0IsQ0FBQ0M7UUFDN0J2QyxTQUFTdUM7SUFDWDtJQUVBLHFCQUNFLDhEQUFDQztRQUFLQyxXQUFXakUsZ0VBQVc7O1lBQ3pCLENBQUN1Qix1QkFDQTs7a0NBQ0UsOERBQUNSLCtEQUFVQTs7Ozs7a0NBQ1gsOERBQUNWLCtEQUFXQTt3QkFBQzZELE1BQU1yQzt3QkFBV3NDLFNBQVM5Qzt3QkFBVStDLGtCQUFrQk47Ozs7Ozs7OzBCQUdyRSw4REFBQzdELDhFQUFxQkE7O29CQUVsQjRCLGFBQWFJLDZCQUNiLDhEQUFDM0IsOERBQVNBO3dCQUFDNEQsTUFBTXJDO3dCQUFXSSxhQUFhQTt3QkFBYVYsT0FBT0E7Ozs7OztvQkFJOURBLHVCQUNDOzswQ0FDRSw4REFBQ1QsMkRBQU1BOzs7OzswQ0FDUCw4REFBQ1AseURBQUtBOzs7OzswQ0FDTiw4REFBQ0MsNERBQVFBO2dDQUFDNkQsT0FBTzFDOzs7Ozs7MENBQ2pCLDhEQUFDbEIseURBQUtBOzs7OzswQ0FDTiw4REFBQ0MsOERBQVVBO2dDQUFDK0MsU0FBUzFCOzs7Ozs7MENBQ3JCLDhEQUFDcEIsMERBQU1BOzs7OzswQ0FDUCw4REFBQ0MsK0RBQVNBOzs7OzswQ0FDViw4REFBQ0MsMkRBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXJCO0dBakh3Qk87S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3BhZ2UuanM/YmU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9wYWdlLm1vZHVsZS5zY3NzJ1xyXG5cclxuaW1wb3J0IHsgTW91c2VQb3NpdGlvblByb3ZpZGVyIH0gZnJvbSAnLi91dGlscy9Nb3VzZVBvc2l0aW9uQ29udGV4dCdcclxuXHJcbmltcG9ydCBMZW5pcyBmcm9tICdAc3R1ZGlvLWZyZWlnaHQvbGVuaXMnXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IExvYWRpbmdwYWdlIGZyb20gJy4vY29tcG9uZW50cy9sb2FkaW5ncGFnZSdcclxuaW1wb3J0IFhtYXNzdHJlZSBmcm9tIFwiLi9jb21wb25lbnRzL3htYXNzX3RyZWVcIlxyXG5pbXBvcnQgSW50cm8gZnJvbSAnLi9jb21wb25lbnRzL2ludHJvJ1xyXG5pbXBvcnQgV2Vkb25hdGUgZnJvbSAnLi9jb21wb25lbnRzL3dlZG9uYXRlJ1xyXG5pbXBvcnQgVmlkZW8gZnJvbSAnLi9jb21wb25lbnRzL3ZpZGVvJ1xyXG5pbXBvcnQgTWVycnlYbWFzcyBmcm9tIFwiLi9jb21wb25lbnRzL21lcnJ5WG1hc3NcIjtcclxuaW1wb3J0IFdpc2hlcyBmcm9tICcuL2NvbXBvbmVudHMvd2lzaGVzJ1xyXG5pbXBvcnQgQXVkaW9JY29uIGZyb20gJy4vY29tcG9uZW50cy9hdWRpb19pY29uJ1xyXG5pbXBvcnQgRm9vdGVyIGZyb20gJy4vY29tcG9uZW50cy9mb290ZXInXHJcblxyXG5pbXBvcnQgSGVhZGVyIGZyb20gJy4vY29tcG9uZW50cy9oZWFkZXInXHJcbmltcG9ydCBIZWFkZXJJbml0IGZyb20gJy4vY29tcG9uZW50cy9oZWFkZXJJbml0J1xyXG5cclxuaW1wb3J0IHNvdXJjZXMgZnJvbSAnLi91dGlscy9zb3VyY2VzJztcclxuXHJcbmltcG9ydCB7IFRleHR1cmVMb2FkZXIgfSBmcm9tICd0aHJlZSdcclxuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXInXHJcbmltcG9ydCB7IFNWR0xvYWRlciB9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9TVkdMb2FkZXJcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xyXG5cclxuICBjb25zdCBbaXNMb2FkZWQsIHNldElzTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG4gIGNvbnN0IFtzdGFydCwgc2V0U3RhcnRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgW2F1ZGlvLCBzZXRBdWRpb10gPSB1c2VTdGF0ZSgpXHJcblxyXG4gIGNvbnN0IFtzYW50YU1vZGVsLCBzZXRTYW50YU1vZGVsXSA9IHVzZVN0YXRlKClcclxuICBjb25zdCBbdHJlZU1vZGVsLCBzZXRUcmVlTW9kZWxdID0gdXNlU3RhdGUoKVxyXG4gIGNvbnN0IFttZXJyeVRleHQsIHNldE1lcnJ5VGV4dF0gPSB1c2VTdGF0ZSgpXHJcbiAgY29uc3QgW3N0YXJUZXh0dXJlLCBzZXRTdGFyVGV4dHVyZV0gPSB1c2VTdGF0ZSgpXHJcblxyXG4gIGxldCBsb2FkZXJzXHJcbiAgbGV0IHRvTG9hZFxyXG4gIGxldCBpdGVtcyA9IHt9XHJcbiAgbGV0IGxvYWRlZCA9IDBcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHRvTG9hZCA9IHNvdXJjZXMubGVuZ3RoO1xyXG4gICAgc2V0TG9hZGVycygpXHJcbiAgICBzdGFydExvYWRpbmcoc291cmNlcylcclxuICB9LCBbXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGxlbmlzID0gbmV3IExlbmlzKClcclxuICAgIGNvbnN0IHJhZiA9ICh0aW1lKSA9PiB7XHJcbiAgICAgIGxlbmlzLnJhZih0aW1lKVxyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmKVxyXG4gICAgfVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZilcclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3Qgc2V0TG9hZGVycyA9ICgpID0+IHtcclxuICAgIGxvYWRlcnMgPSB7fTtcclxuICAgIGxvYWRlcnMuZ2x0ZkxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XHJcbiAgICBsb2FkZXJzLnRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xyXG4gICAgbG9hZGVycy5zdmdMb2FkZXIgPSBuZXcgU1ZHTG9hZGVyKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzdGFydExvYWRpbmcgPSAoYWxsU291cmNlcykgPT4ge1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBhbGxTb3VyY2VzKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS50eXBlID09PSBcImdsdGZNb2RlbFwiKSB7XHJcbiAgICAgICAgICBsb2FkZXJzLmdsdGZMb2FkZXIubG9hZChzb3VyY2UucGF0aCwgKG1vZGVsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UubmFtZSA9PT0gJ3NhbnRhY2xhdXMnKSB7XHJcbiAgICAgICAgICAgICAgc2V0U2FudGFNb2RlbChtb2RlbClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5uYW1lID09PSAndHJlZScpIHtcclxuICAgICAgICAgICAgICBzZXRUcmVlTW9kZWwobW9kZWwpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc291cmNlTG9hZGVkKHNvdXJjZSwgbW9kZWwpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PT0gXCJ0ZXh0dXJlTW9kZWxcIikge1xyXG4gICAgICAgICAgbG9hZGVycy50ZXh0dXJlTG9hZGVyLmxvYWQoc291cmNlLnBhdGgsICh0ZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UubmFtZSA9PT0gJ21lcnJ5Q2hyaXN0bWFzJykge1xyXG4gICAgICAgICAgICAgIHNldE1lcnJ5VGV4dCh0ZXh0dXJlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UubmFtZSA9PT0gJ3N0YXInKSB7XHJcbiAgICAgICAgICAgICAgc2V0U3RhclRleHR1cmUodGV4dHVyZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzb3VyY2VMb2FkZWQoc291cmNlLCB0ZXh0dXJlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnR5cGUgPT09IFwic3ZnTW9kZWxcIikge1xyXG4gICAgICAgICAgbG9hZGVycy5zdmdMb2FkZXIubG9hZChzb3VyY2UucGF0aCwgKHN2ZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdmcpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0gICAgIFxyXG4gIH1cclxuXHJcbiAgY29uc3Qgc291cmNlTG9hZGVkID0gKHNvdXJjZSwgZmlsZSkgPT4ge1xyXG4gICAgaXRlbXNbc291cmNlLm5hbWVdID0gZmlsZTtcclxuICAgIGxvYWRlZCsrO1xyXG4gICAgaWYgKGxvYWRlZCA9PT0gdG9Mb2FkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcqKiBSRUFEWSAqKicpXHJcbiAgICAgIHNldElzTG9hZGVkKHRydWUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCByZWNlaXZlRGF0YUZyb21CdXR0b24gPSAoZGF0YSkgPT4ge1xyXG4gICAgc2V0U3RhcnQoZGF0YSlcclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8bWFpbiBjbGFzc05hbWU9e3N0eWxlcy5tYWlufT5cclxuICAgICAgeyFzdGFydCAmJiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgIDxIZWFkZXJJbml0IC8+XHJcbiAgICAgICAgICA8TG9hZGluZ3BhZ2UgdHJlZT17dHJlZU1vZGVsfSBzaG93YnRuPXtpc0xvYWRlZH0gc2VuZERhdGFUb1BhcmVudD17cmVjZWl2ZURhdGFGcm9tQnV0dG9ufS8+XHJcbiAgICAgICAgPC8+XHJcbiAgICAgICl9XHJcbiAgICAgICAgPE1vdXNlUG9zaXRpb25Qcm92aWRlcj5cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgeyh0cmVlTW9kZWwgJiYgc3RhclRleHR1cmUpICYmICggICAgICAgICAgICBcclxuICAgICAgICAgICAgPFhtYXNzdHJlZSB0cmVlPXt0cmVlTW9kZWx9IHN0YXJUZXh0dXJlPXtzdGFyVGV4dHVyZX0gc3RhcnQ9e3N0YXJ0fS8+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgICAgXHJcblxyXG4gICAgICAgICAge3N0YXJ0ICYmIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICA8SGVhZGVyIC8+XHJcbiAgICAgICAgICAgICAgPEludHJvIC8+XHJcbiAgICAgICAgICAgICAgPFdlZG9uYXRlIHNhbnRhPXtzYW50YU1vZGVsfSAvPlxyXG4gICAgICAgICAgICAgIDxWaWRlbyAvPlxyXG4gICAgICAgICAgICAgIDxNZXJyeVhtYXNzIHRleHR1cmU9e21lcnJ5VGV4dH0gLz5cclxuICAgICAgICAgICAgICA8V2lzaGVzIC8+XHJcbiAgICAgICAgICAgICAgPEF1ZGlvSWNvbi8+XHJcbiAgICAgICAgICAgICAgPEZvb3RlciAvPlxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICl9XHJcbiAgICAgICAgPC9Nb3VzZVBvc2l0aW9uUHJvdmlkZXI+ICAgIFxyXG4gICAgPC9tYWluPlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsic3R5bGVzIiwiTW91c2VQb3NpdGlvblByb3ZpZGVyIiwiTGVuaXMiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkxvYWRpbmdwYWdlIiwiWG1hc3N0cmVlIiwiSW50cm8iLCJXZWRvbmF0ZSIsIlZpZGVvIiwiTWVycnlYbWFzcyIsIldpc2hlcyIsIkF1ZGlvSWNvbiIsIkZvb3RlciIsIkhlYWRlciIsIkhlYWRlckluaXQiLCJzb3VyY2VzIiwiVGV4dHVyZUxvYWRlciIsIkdMVEZMb2FkZXIiLCJTVkdMb2FkZXIiLCJIb21lIiwiaXNMb2FkZWQiLCJzZXRJc0xvYWRlZCIsInN0YXJ0Iiwic2V0U3RhcnQiLCJhdWRpbyIsInNldEF1ZGlvIiwic2FudGFNb2RlbCIsInNldFNhbnRhTW9kZWwiLCJ0cmVlTW9kZWwiLCJzZXRUcmVlTW9kZWwiLCJtZXJyeVRleHQiLCJzZXRNZXJyeVRleHQiLCJzdGFyVGV4dHVyZSIsInNldFN0YXJUZXh0dXJlIiwibG9hZGVycyIsInRvTG9hZCIsIml0ZW1zIiwibG9hZGVkIiwibGVuZ3RoIiwic2V0TG9hZGVycyIsInN0YXJ0TG9hZGluZyIsImxlbmlzIiwicmFmIiwidGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdsdGZMb2FkZXIiLCJ0ZXh0dXJlTG9hZGVyIiwic3ZnTG9hZGVyIiwiYWxsU291cmNlcyIsInNvdXJjZSIsInR5cGUiLCJsb2FkIiwicGF0aCIsIm1vZGVsIiwibmFtZSIsInNvdXJjZUxvYWRlZCIsInRleHR1cmUiLCJzdmciLCJjb25zb2xlIiwibG9nIiwiZmlsZSIsInJlY2VpdmVEYXRhRnJvbUJ1dHRvbiIsImRhdGEiLCJtYWluIiwiY2xhc3NOYW1lIiwidHJlZSIsInNob3didG4iLCJzZW5kRGF0YVRvUGFyZW50Iiwic2FudGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/loaders/SVGLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/SVGLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGLoader: function() { return /* binding */ SVGLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\r\n\r\nconst COLOR_SPACE_SVG = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\r\n\r\nclass SVGLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\t// Default dots per inch\r\n\t\tthis.defaultDPI = 90;\r\n\r\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\r\n\t\tthis.defaultUnit = 'px';\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\r\n\t\tloader.setPath( scope.path );\r\n\t\tloader.setRequestHeader( scope.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( text ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tfunction parseNode( node, style ) {\r\n\r\n\t\t\tif ( node.nodeType !== 1 ) return;\r\n\r\n\t\t\tconst transform = getNodeTransform( node );\r\n\r\n\t\t\tlet isDefsNode = false;\r\n\r\n\t\t\tlet path = null;\r\n\r\n\t\t\tswitch ( node.nodeName ) {\r\n\r\n\t\t\t\tcase 'svg':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'style':\r\n\t\t\t\t\tparseCSSStylesheet( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'g':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'path':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rect':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseRectNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polygon':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolygonNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polyline':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolylineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'circle':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseCircleNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ellipse':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseEllipseNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'line':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseLineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'defs':\r\n\t\t\t\t\tisDefsNode = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'use':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\r\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\r\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\r\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\r\n\t\t\t\t\tif ( usedNode ) {\r\n\r\n\t\t\t\t\t\tparseNode( usedNode, style );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// console.log( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( path ) {\r\n\r\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\r\n\r\n\t\t\t\t\tpath.color.setStyle( style.fill, COLOR_SPACE_SVG );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransformPath( path, currentTransform );\r\n\r\n\t\t\t\tpaths.push( path );\r\n\r\n\t\t\t\tpath.userData = { node: node, style: style };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst childNodes = node.childNodes;\r\n\r\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tconst node = childNodes[ i ];\r\n\r\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\r\n\r\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\r\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\r\n\t\t\t\t\t// <style/> there.\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparseNode( node, style );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( transform ) {\r\n\r\n\t\t\t\ttransformStack.pop();\r\n\r\n\t\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePathNode( node ) {\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\r\n\t\t\tconst point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\t\tconst control = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\r\n\t\t\tconst firstPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\t\tlet isFirstPoint = true;\r\n\t\t\tlet doSetFirstPoint = false;\r\n\r\n\t\t\tconst d = node.getAttribute( 'd' );\r\n\r\n\t\t\tif ( d === '' || d === 'none' ) return null;\r\n\r\n\t\t\t// console.log( d );\r\n\r\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\r\n\r\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst command = commands[ i ];\r\n\r\n\t\t\t\tconst type = command.charAt( 0 );\r\n\t\t\t\tconst data = command.slice( 1 ).trim();\r\n\r\n\t\t\t\tif ( isFirstPoint === true ) {\r\n\r\n\t\t\t\t\tdoSetFirstPoint = true;\r\n\t\t\t\t\tisFirstPoint = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet numbers;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'L':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'C':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Q':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if start point == end point\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\r\n\r\n\t\t\t\t\t\t\tconst start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if no displacement\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\r\n\r\n\t\t\t\t\t\t\tconst start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\t// Reset point to beginning of Path\r\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\r\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\r\n\t\t\t\t\t\t\tisFirstPoint = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( command );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\r\n\r\n\t\t\t\tdoSetFirstPoint = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCSSStylesheet( node ) {\r\n\r\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\r\n\r\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\r\n\r\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\r\n\r\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\r\n\r\n\t\t\t\tconst selectorList = stylesheet.selectorText\r\n\t\t\t\t\t.split( /,/gm )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\r\n\r\n\t\t\t\t\t// Remove empty rules\r\n\t\t\t\t\tconst definitions = Object.fromEntries(\r\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\r\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\r\n\t\t\t\t\t\tdefinitions\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\r\n\t\t * From\r\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n\t\t * To\r\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\r\n\t\t */\r\n\r\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\r\n\r\n\t\t\tif ( rx == 0 || ry == 0 ) {\r\n\r\n\t\t\t\t// draw a line if either of the radii == 0\r\n\t\t\t\tpath.lineTo( end.x, end.y );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\r\n\r\n\t\t\t// Ensure radii are positive\r\n\t\t\trx = Math.abs( rx );\r\n\t\t\try = Math.abs( ry );\r\n\r\n\t\t\t// Compute (x1', y1')\r\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\r\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\r\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\r\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\r\n\r\n\t\t\t// Compute (cx', cy')\r\n\t\t\tlet rxs = rx * rx;\r\n\t\t\tlet rys = ry * ry;\r\n\t\t\tconst x1ps = x1p * x1p;\r\n\t\t\tconst y1ps = y1p * y1p;\r\n\r\n\t\t\t// Ensure radii are large enough\r\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\r\n\r\n\t\t\tif ( cr > 1 ) {\r\n\r\n\t\t\t\t// scale up rx,ry equally so cr == 1\r\n\t\t\t\tconst s = Math.sqrt( cr );\r\n\t\t\t\trx = s * rx;\r\n\t\t\t\try = s * ry;\r\n\t\t\t\trxs = rx * rx;\r\n\t\t\t\trys = ry * ry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\r\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\r\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\r\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\r\n\t\t\tconst cxp = q * rx * y1p / ry;\r\n\t\t\tconst cyp = - q * ry * x1p / rx;\r\n\r\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\r\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\r\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\r\n\r\n\t\t\t// Step 4: Compute θ1 and Δθ\r\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\r\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\r\n\r\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\r\n\r\n\t\t}\r\n\r\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\r\n\r\n\t\t\tconst dot = ux * vx + uy * vy;\r\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\r\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\r\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\r\n\t\t\treturn ang;\r\n\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\r\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\r\n\t\t*/\r\n\t\tfunction parseRectNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\r\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\r\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\r\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\r\n\r\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\r\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\r\n\t\t\tconst bci = 1 - 0.551915024494;\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\r\n\t\t\t// top left\r\n\t\t\tpath.moveTo( x + rx, y );\r\n\r\n\t\t\t// top right\r\n\t\t\tpath.lineTo( x + w - rx, y );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + w - rx * bci,\r\n\t\t\t\t\ty,\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + ry * bci,\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + ry\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom right\r\n\t\t\tpath.lineTo( x + w, y + h - ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + h - ry * bci,\r\n\t\t\t\t\tx + w - rx * bci,\r\n\t\t\t\t\ty + h,\r\n\t\t\t\t\tx + w - rx,\r\n\t\t\t\t\ty + h\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom left\r\n\t\t\tpath.lineTo( x + rx, y + h );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + rx * bci,\r\n\t\t\t\t\ty + h,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty + h - ry * bci,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty + h - ry\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// back to top left\r\n\t\t\tpath.lineTo( x, y + ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolygonNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tconst x = parseFloatWithUnits( a );\r\n\t\t\t\tconst y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolylineNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tconst x = parseFloatWithUnits( a );\r\n\t\t\t\tconst y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCircleNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\r\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\r\n\r\n\t\t\tconst subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\r\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEllipseNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\r\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\r\n\r\n\t\t\tconst subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\r\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLineNode( node ) {\r\n\r\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\r\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\r\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\r\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\r\n\r\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\r\n\t\t\tpath.moveTo( x1, y1 );\r\n\t\t\tpath.lineTo( x2, y2 );\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction parseStyle( node, style ) {\r\n\r\n\t\t\tstyle = Object.assign( {}, style ); // clone style\r\n\r\n\t\t\tlet stylesheetStyles = {};\r\n\r\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\r\n\r\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\r\n\t\t\t\t\t.split( /\\s/ )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\r\n\r\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\r\n\r\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\r\n\r\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\r\n\r\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\r\n\r\n\t\t\t\t\treturn v;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\r\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\r\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction clamp( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction positive( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddStyle( 'fill', 'fill' );\r\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\r\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\r\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\r\n\t\t\taddStyle( 'stroke', 'stroke' );\r\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\r\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\r\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\r\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\r\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\r\n\t\t\taddStyle( 'visibility', 'visibility' );\r\n\r\n\t\t\treturn style;\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\r\n\r\n\t\tfunction getReflection( a, b ) {\r\n\r\n\t\t\treturn a - ( b - a );\r\n\r\n\t\t}\r\n\r\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\r\n\r\n\t\tfunction parseFloats( input, flags, stride ) {\r\n\r\n\t\t\tif ( typeof input !== 'string' ) {\r\n\r\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Character groups\r\n\t\t\tconst RE = {\r\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\r\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\r\n\t\t\t\tDIGIT: /[\\d]/,\r\n\t\t\t\tSIGN: /[-+]/,\r\n\t\t\t\tPOINT: /\\./,\r\n\t\t\t\tCOMMA: /,/,\r\n\t\t\t\tEXP: /e/i,\r\n\t\t\t\tFLAGS: /[01]/\r\n\t\t\t};\r\n\r\n\t\t\t// States\r\n\t\t\tconst SEP = 0;\r\n\t\t\tconst INT = 1;\r\n\t\t\tconst FLOAT = 2;\r\n\t\t\tconst EXP = 3;\r\n\r\n\t\t\tlet state = SEP;\r\n\t\t\tlet seenComma = true;\r\n\t\t\tlet number = '', exponent = '';\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\r\n\r\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\r\n\t\t\t\terror.partial = partial;\r\n\t\t\t\tthrow error;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction newNumber() {\r\n\r\n\t\t\t\tif ( number !== '' ) {\r\n\r\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\r\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnumber = '';\r\n\t\t\t\texponent = '';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet current;\r\n\t\t\tconst length = input.length;\r\n\r\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tcurrent = input[ i ];\r\n\r\n\t\t\t\t// check for flags\r\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\r\n\r\n\t\t\t\t\tstate = INT;\r\n\t\t\t\t\tnumber = current;\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse until next number\r\n\t\t\t\tif ( state === SEP ) {\r\n\r\n\t\t\t\t\t// eat whitespace\r\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// start new number\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = INT;\r\n\t\t\t\t\t\tnumber = current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\t\tnumber = current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\r\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\r\n\r\n\t\t\t\t\t\tif ( seenComma ) {\r\n\r\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tseenComma = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse integer part\r\n\t\t\t\tif ( state === INT ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = EXP;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\r\n\t\t\t\t\tif ( RE.SIGN.test( current )\r\n\t\t\t\t\t\t\t&& number.length === 1\r\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\r\n\r\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse decimal part\r\n\t\t\t\tif ( state === FLOAT ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = EXP;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\r\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\r\n\r\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse exponent part\r\n\t\t\t\tif ( state === EXP ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\texponent += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\t\tif ( exponent === '' ) {\r\n\r\n\t\t\t\t\t\t\texponent += current;\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\r\n\r\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// end of number\r\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = SEP;\r\n\t\t\t\t\tseenComma = false;\r\n\r\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = SEP;\r\n\t\t\t\t\tseenComma = true;\r\n\r\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = INT;\r\n\t\t\t\t\tnumber = current;\r\n\r\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\tnumber = current;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add the last number found (if any)\r\n\t\t\tnewNumber();\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// Units\r\n\r\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\r\n\r\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\r\n\t\tconst unitConversion = {\r\n\r\n\t\t\t'mm': {\r\n\t\t\t\t'mm': 1,\r\n\t\t\t\t'cm': 0.1,\r\n\t\t\t\t'in': 1 / 25.4,\r\n\t\t\t\t'pt': 72 / 25.4,\r\n\t\t\t\t'pc': 6 / 25.4,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'cm': {\r\n\t\t\t\t'mm': 10,\r\n\t\t\t\t'cm': 1,\r\n\t\t\t\t'in': 1 / 2.54,\r\n\t\t\t\t'pt': 72 / 2.54,\r\n\t\t\t\t'pc': 6 / 2.54,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'in': {\r\n\t\t\t\t'mm': 25.4,\r\n\t\t\t\t'cm': 2.54,\r\n\t\t\t\t'in': 1,\r\n\t\t\t\t'pt': 72,\r\n\t\t\t\t'pc': 6,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pt': {\r\n\t\t\t\t'mm': 25.4 / 72,\r\n\t\t\t\t'cm': 2.54 / 72,\r\n\t\t\t\t'in': 1 / 72,\r\n\t\t\t\t'pt': 1,\r\n\t\t\t\t'pc': 6 / 72,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pc': {\r\n\t\t\t\t'mm': 25.4 / 6,\r\n\t\t\t\t'cm': 2.54 / 6,\r\n\t\t\t\t'in': 1 / 6,\r\n\t\t\t\t'pt': 72 / 6,\r\n\t\t\t\t'pc': 1,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'px': {\r\n\t\t\t\t'px': 1\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseFloatWithUnits( string ) {\r\n\r\n\t\t\tlet theUnit = 'px';\r\n\r\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\r\n\r\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\r\n\r\n\t\t\t\t\tconst u = units[ i ];\r\n\r\n\t\t\t\t\tif ( string.endsWith( u ) ) {\r\n\r\n\t\t\t\t\t\ttheUnit = u;\r\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet scale = undefined;\r\n\r\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\r\n\r\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\r\n\r\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\r\n\r\n\t\t\t\tif ( scale < 0 ) {\r\n\r\n\t\t\t\t\t// Conversion scale to pixels\r\n\r\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn scale * parseFloat( string );\r\n\r\n\t\t}\r\n\r\n\t\t// Transforms\r\n\r\n\t\tfunction getNodeTransform( node ) {\r\n\r\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst transform = parseNodeTransform( node );\r\n\r\n\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentTransform.copy( transform );\r\n\t\t\ttransformStack.push( transform );\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNodeTransform( node ) {\r\n\r\n\t\t\tconst transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\n\t\t\tconst currentTransform = tempTransform0;\r\n\r\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\r\n\r\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\r\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\r\n\r\n\t\t\t\ttransform.translate( tx, ty );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\r\n\r\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\r\n\r\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\r\n\r\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\r\n\r\n\t\t\t\t\tif ( transformText === '' ) continue;\r\n\r\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\r\n\t\t\t\t\tconst closeParPos = transformText.length;\r\n\r\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\r\n\r\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\r\n\r\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\r\n\r\n\t\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t\t\tswitch ( transformType ) {\r\n\r\n\t\t\t\t\t\t\tcase 'translate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tlet ty = 0;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'rotate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tlet angle = 0;\r\n\t\t\t\t\t\t\t\t\tlet cx = 0;\r\n\t\t\t\t\t\t\t\t\tlet cy = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t// Angle\r\n\t\t\t\t\t\t\t\t\tangle = array[ 0 ] * Math.PI / 180;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Center x, y\r\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\r\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\r\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( - cx, - cy );\r\n\t\t\t\t\t\t\t\t\ttempTransform2.makeRotation( angle );\r\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\r\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( cx, cy );\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'scale':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewX':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewY':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\r\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'matrix':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\r\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttransform.premultiply( currentTransform );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction transformPath( path, m ) {\r\n\r\n\t\t\tfunction transfVec2( v2 ) {\r\n\r\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\r\n\r\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transfEllipseGeneric( curve ) {\r\n\r\n\t\t\t\t// For math description see:\r\n\t\t\t\t// https://math.stackexchange.com/questions/4544164\r\n\r\n\t\t\t\tconst a = curve.xRadius;\r\n\t\t\t\tconst b = curve.yRadius;\r\n\r\n\t\t\t\tconst cosTheta = Math.cos( curve.aRotation );\r\n\t\t\t\tconst sinTheta = Math.sin( curve.aRotation );\r\n\r\n\t\t\t\tconst v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( a * cosTheta, a * sinTheta, 0 );\r\n\t\t\t\tconst v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( - b * sinTheta, b * cosTheta, 0 );\r\n\r\n\t\t\t\tconst f1 = v1.applyMatrix3( m );\r\n\t\t\t\tconst f2 = v2.applyMatrix3( m );\r\n\r\n\t\t\t\tconst mF = tempTransform0.set(\r\n\t\t\t\t\tf1.x, f2.x, 0,\r\n\t\t\t\t\tf1.y, f2.y, 0,\r\n\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst mFInv = tempTransform1.copy( mF ).invert();\r\n\t\t\t\tconst mFInvT = tempTransform2.copy( mFInv ).transpose();\r\n\t\t\t\tconst mQ = mFInvT.multiply( mFInv );\r\n\t\t\t\tconst mQe = mQ.elements;\r\n\r\n\t\t\t\tconst ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );\r\n\t\t\t\tconst rt1sqrt = Math.sqrt( ed.rt1 );\r\n\t\t\t\tconst rt2sqrt = Math.sqrt( ed.rt2 );\r\n\r\n\t\t\t\tcurve.xRadius = 1 / rt1sqrt;\r\n\t\t\t\tcurve.yRadius = 1 / rt2sqrt;\r\n\t\t\t\tcurve.aRotation = Math.atan2( ed.sn, ed.cs );\r\n\r\n\t\t\t\tconst isFullEllipse =\r\n\t\t\t\t\t( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;\r\n\r\n\t\t\t\t// Do not touch angles of a full ellipse because after transformation they\r\n\t\t\t\t// would converge to a sinle value effectively removing the whole curve\r\n\r\n\t\t\t\tif ( ! isFullEllipse ) {\r\n\r\n\t\t\t\t\tconst mDsqrt = tempTransform1.set(\r\n\t\t\t\t\t\trt1sqrt, 0, 0,\r\n\t\t\t\t\t\t0, rt2sqrt, 0,\r\n\t\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tconst mRT = tempTransform2.set(\r\n\t\t\t\t\t\ted.cs, ed.sn, 0,\r\n\t\t\t\t\t\t- ed.sn, ed.cs, 0,\r\n\t\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tconst mDRF = mDsqrt.multiply( mRT ).multiply( mF );\r\n\r\n\t\t\t\t\tconst transformAngle = phi => {\r\n\r\n\t\t\t\t\t\tconst { x: cosR, y: sinR } =\r\n\t\t\t\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );\r\n\r\n\t\t\t\t\t\treturn Math.atan2( sinR, cosR );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tcurve.aStartAngle = transformAngle( curve.aStartAngle );\r\n\t\t\t\t\tcurve.aEndAngle = transformAngle( curve.aEndAngle );\r\n\r\n\t\t\t\t\tif ( isTransformFlipped( m ) ) {\r\n\r\n\t\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transfEllipseNoSkew( curve ) {\r\n\r\n\t\t\t\t// Faster shortcut if no skew is applied\r\n\t\t\t\t// (e.g, a euclidean transform of a group containing the ellipse)\r\n\r\n\t\t\t\tconst sx = getTransformScaleX( m );\r\n\t\t\t\tconst sy = getTransformScaleY( m );\r\n\r\n\t\t\t\tcurve.xRadius *= sx;\r\n\t\t\t\tcurve.yRadius *= sy;\r\n\r\n\t\t\t\t// Extract rotation angle from the matrix of form:\r\n\t\t\t\t//\r\n\t\t\t\t//  | cosθ sx   -sinθ sy |\r\n\t\t\t\t//  | sinθ sx    cosθ sy |\r\n\t\t\t\t//\r\n\t\t\t\t// Remembering that tanθ = sinθ / cosθ; and that\r\n\t\t\t\t// `sx`, `sy`, or both might be zero.\r\n\t\t\t\tconst theta =\r\n\t\t\t\t\tsx > Number.EPSILON\r\n\t\t\t\t\t\t? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )\r\n\t\t\t\t\t\t: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );\r\n\r\n\t\t\t\tcurve.aRotation += theta;\r\n\r\n\t\t\t\tif ( isTransformFlipped( m ) ) {\r\n\r\n\t\t\t\t\tcurve.aStartAngle *= - 1;\r\n\t\t\t\t\tcurve.aEndAngle *= - 1;\r\n\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst subPaths = path.subPaths;\r\n\r\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\r\n\r\n\t\t\t\tconst subPath = subPaths[ i ];\r\n\t\t\t\tconst curves = subPath.curves;\r\n\r\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\r\n\r\n\t\t\t\t\tconst curve = curves[ j ];\r\n\r\n\t\t\t\t\tif ( curve.isLineCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\t\t\t\t\t\ttransfVec2( curve.v3 );\r\n\r\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\r\n\r\n\t\t\t\t\t\t// Transform ellipse center point\r\n\r\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\r\n\t\t\t\t\t\ttransfVec2( tempV2 );\r\n\t\t\t\t\t\tcurve.aX = tempV2.x;\r\n\t\t\t\t\t\tcurve.aY = tempV2.y;\r\n\r\n\t\t\t\t\t\t// Transform ellipse shape parameters\r\n\r\n\t\t\t\t\t\tif ( isTransformSkewed( m ) ) {\r\n\r\n\t\t\t\t\t\t\ttransfEllipseGeneric( curve );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttransfEllipseNoSkew( curve );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformFlipped( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformSkewed( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\tconst basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];\r\n\r\n\t\t\t// Shortcut for trivial rotations and transformations\r\n\t\t\tif ( basisDot === 0 ) return false;\r\n\r\n\t\t\tconst sx = getTransformScaleX( m );\r\n\t\t\tconst sy = getTransformScaleY( m );\r\n\r\n\t\t\treturn Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleX( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleY( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\r\n\r\n\t\t}\r\n\r\n\t\t// Calculates the eigensystem of a real symmetric 2x2 matrix\r\n\t\t//    [ A  B ]\r\n\t\t//    [ B  C ]\r\n\t\t// in the form\r\n\t\t//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\r\n\t\t//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\r\n\t\t// where rt1 >= rt2.\r\n\t\t//\r\n\t\t// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\r\n\t\t// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\r\n\t\tfunction eigenDecomposition( A, B, C ) {\r\n\r\n\t\t\tlet rt1, rt2, cs, sn, t;\r\n\t\t\tconst sm = A + C;\r\n\t\t\tconst df = A - C;\r\n\t\t\tconst rt = Math.sqrt( df * df + 4 * B * B );\r\n\r\n\t\t\tif ( sm > 0 ) {\r\n\r\n\t\t\t\trt1 = 0.5 * ( sm + rt );\r\n\t\t\t\tt = 1 / rt1;\r\n\t\t\t\trt2 = A * t * C - B * t * B;\r\n\r\n\t\t\t} else if ( sm < 0 ) {\r\n\r\n\t\t\t\trt2 = 0.5 * ( sm - rt );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// This case needs to be treated separately to avoid div by 0\r\n\r\n\t\t\t\trt1 = 0.5 * rt;\r\n\t\t\t\trt2 = - 0.5 * rt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Calculate eigenvectors\r\n\r\n\t\t\tif ( df > 0 ) {\r\n\r\n\t\t\t\tcs = df + rt;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcs = df - rt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( Math.abs( cs ) > 2 * Math.abs( B ) ) {\r\n\r\n\t\t\t\tt = - 2 * B / cs;\r\n\t\t\t\tsn = 1 / Math.sqrt( 1 + t * t );\r\n\t\t\t\tcs = t * sn;\r\n\r\n\t\t\t} else if ( Math.abs( B ) === 0 ) {\r\n\r\n\t\t\t\tcs = 1;\r\n\t\t\t\tsn = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tt = - 0.5 * cs / B;\r\n\t\t\t\tcs = 1 / Math.sqrt( 1 + t * t );\r\n\t\t\t\tsn = t * cs;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( df > 0 ) {\r\n\r\n\t\t\t\tt = cs;\r\n\t\t\t\tcs = - sn;\r\n\t\t\t\tsn = t;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { rt1, rt2, cs, sn };\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst paths = [];\r\n\t\tconst stylesheets = {};\r\n\r\n\t\tconst transformStack = [];\r\n\r\n\t\tconst tempTransform0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\n\t\tconst tempTransform1 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\n\t\tconst tempTransform2 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\n\t\tconst tempTransform3 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\n\t\tconst tempV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\r\n\r\n\t\tconst currentTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\r\n\r\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\r\n\r\n\t\tparseNode( xml.documentElement, {\r\n\t\t\tfill: '#000',\r\n\t\t\tfillOpacity: 1,\r\n\t\t\tstrokeOpacity: 1,\r\n\t\t\tstrokeWidth: 1,\r\n\t\t\tstrokeLineJoin: 'miter',\r\n\t\t\tstrokeLineCap: 'butt',\r\n\t\t\tstrokeMiterLimit: 4\r\n\t\t} );\r\n\r\n\t\tconst data = { paths: paths, xml: xml.documentElement };\r\n\r\n\t\t// console.log( paths );\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tstatic createShapes( shapePath ) {\r\n\r\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\r\n\t\t// Returns Shape object\r\n\r\n\t\tconst BIGNUMBER = 999999999;\r\n\r\n\t\tconst IntersectionLocationType = {\r\n\t\t\tORIGIN: 0,\r\n\t\t\tDESTINATION: 1,\r\n\t\t\tBETWEEN: 2,\r\n\t\t\tLEFT: 3,\r\n\t\t\tRIGHT: 4,\r\n\t\t\tBEHIND: 5,\r\n\t\t\tBEYOND: 6\r\n\t\t};\r\n\r\n\t\tconst classifyResult = {\r\n\t\t\tloc: IntersectionLocationType.ORIGIN,\r\n\t\t\tt: 0\r\n\t\t};\r\n\r\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\r\n\r\n\t\t\tconst x1 = a0.x;\r\n\t\t\tconst x2 = a1.x;\r\n\t\t\tconst x3 = b0.x;\r\n\t\t\tconst x4 = b1.x;\r\n\t\t\tconst y1 = a0.y;\r\n\t\t\tconst y2 = a1.y;\r\n\t\t\tconst y3 = b0.y;\r\n\t\t\tconst y4 = b1.y;\r\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\r\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\r\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\r\n\t\t\tconst t1 = nom1 / denom;\r\n\t\t\tconst t2 = nom2 / denom;\r\n\r\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\r\n\r\n\t\t\t\t//1. lines are parallel or edges don't intersect\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\r\n\r\n\t\t\t\t//2. lines are colinear\r\n\r\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\r\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\r\n\r\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\r\n\t\t\t\t\t//find position of this endpoints relatively to edge1\r\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\r\n\r\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\r\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\r\n\r\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\r\n\r\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\r\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\r\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//3. edges intersect\r\n\r\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\r\n\r\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\r\n\r\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\r\n\r\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\r\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\r\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\r\n\t\t\t\treturn { x: x, y: y, t: t1 };\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\r\n\r\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\r\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\r\n\t\t\tconst bx = p.x - edgeStart.x;\r\n\t\t\tconst by = p.y - edgeStart.y;\r\n\t\t\tconst sa = ax * by - bx * ay;\r\n\r\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\r\n\t\t\t\tclassifyResult.t = 0;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\r\n\t\t\t\tclassifyResult.t = 1;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sa < - Number.EPSILON ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sa > Number.EPSILON ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\r\n\t\t\t\treturn;\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet t;\r\n\r\n\t\t\tif ( ax !== 0 ) {\r\n\r\n\t\t\t\tt = bx / ax;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tt = by / ay;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\r\n\t\t\tclassifyResult.t = t;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getIntersections( path1, path2 ) {\r\n\r\n\t\t\tconst intersectionsRaw = [];\r\n\t\t\tconst intersections = [];\r\n\r\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\r\n\r\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\r\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\r\n\r\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\r\n\r\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\r\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\r\n\r\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\r\n\r\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\r\n\r\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\r\n\t\t\t\t\t\tintersections.push( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( intersection.x, intersection.y ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn intersections;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\r\n\r\n\t\t\tconst center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\t\tboundingBox.getCenter( center );\r\n\r\n\t\t\tconst allIntersections = [];\r\n\r\n\t\t\tpaths.forEach( path => {\r\n\r\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\r\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\r\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\r\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\r\n\r\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\r\n\r\n\t\t\t\t\tintersections.forEach( p => {\r\n\r\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\r\n\r\n\t\t\t\treturn i1.point.x - i2.point.x;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn allIntersections;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\r\n\r\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\r\n\r\n\t\t\t\t_fillRule = 'nonzero';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst centerBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\r\n\r\n\t\t\tconst scanline = [ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scanlineMinX, centerBoundingBox.y ), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scanlineMaxX, centerBoundingBox.y ) ];\r\n\r\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\r\n\r\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\r\n\r\n\t\t\t\treturn i1.point.x - i2.point.x;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst baseIntersections = [];\r\n\t\t\tconst otherIntersections = [];\r\n\r\n\t\t\tscanlineIntersections.forEach( i => {\r\n\r\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\r\n\r\n\t\t\t\t\tbaseIntersections.push( i );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\totherIntersections.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\r\n\r\n\t\t\t// build up the path hierarchy\r\n\t\t\tconst stack = [];\r\n\t\t\tlet i = 0;\r\n\r\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\r\n\r\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\r\n\r\n\t\t\t\t\tstack.pop();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstack.push( simplePath.identifier );\r\n\r\n\t\t\tif ( _fillRule === 'evenodd' ) {\r\n\r\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\r\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\r\n\r\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\r\n\r\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\r\n\r\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\r\n\t\t\t\tlet isHole = true;\r\n\t\t\t\tlet isHoleFor = null;\r\n\t\t\t\tlet lastCWValue = null;\r\n\r\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\r\n\r\n\t\t\t\t\tconst identifier = stack[ i ];\r\n\t\t\t\t\tif ( isHole ) {\r\n\r\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\r\n\t\t\t\t\t\tisHole = false;\r\n\t\t\t\t\t\tisHoleFor = identifier;\r\n\r\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\r\n\r\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\r\n\t\t\t\t\t\tisHole = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check for self intersecting paths\r\n\t\t// TODO\r\n\r\n\t\t// check intersecting paths\r\n\t\t// TODO\r\n\r\n\t\t// prepare paths for hole detection\r\n\t\tlet scanlineMinX = BIGNUMBER;\r\n\t\tlet scanlineMaxX = - BIGNUMBER;\r\n\r\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\r\n\r\n\t\t\tconst points = p.getPoints();\r\n\t\t\tlet maxY = - BIGNUMBER;\r\n\t\t\tlet minY = BIGNUMBER;\r\n\t\t\tlet maxX = - BIGNUMBER;\r\n\t\t\tlet minX = BIGNUMBER;\r\n\r\n\t      \t//points.forEach(p => p.y *= -1);\r\n\r\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\r\n\r\n\t\t\t\tconst p = points[ i ];\r\n\r\n\t\t\t\tif ( p.y > maxY ) {\r\n\r\n\t\t\t\t\tmaxY = p.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.y < minY ) {\r\n\r\n\t\t\t\t\tminY = p.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.x > maxX ) {\r\n\r\n\t\t\t\t\tmaxX = p.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.x < minX ) {\r\n\r\n\t\t\t\t\tminX = p.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\t\t\tif ( scanlineMaxX <= maxX ) {\r\n\r\n\t\t\t\tscanlineMaxX = maxX + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scanlineMinX >= minX ) {\r\n\r\n\t\t\t\tscanlineMinX = minX - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { curves: p.curves, points: points, isCW: three__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new three__WEBPACK_IMPORTED_MODULE_0__.Box2( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( minX, minY ), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( maxX, maxY ) ) };\r\n\r\n\t\t} );\r\n\r\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\r\n\r\n\t\tfor ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {\r\n\r\n\t\t\tsimplePaths[ identifier ].identifier = identifier;\r\n\r\n\t\t}\r\n\r\n\t\t// check if path is solid or a hole\r\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );\r\n\r\n\r\n\t\tconst shapesToReturn = [];\r\n\t\tsimplePaths.forEach( p => {\r\n\r\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\r\n\r\n\t\t\tif ( ! amIAHole.isHole ) {\r\n\r\n\t\t\t\tconst shape = new three__WEBPACK_IMPORTED_MODULE_0__.Shape();\r\n\t\t\t\tshape.curves = p.curves;\r\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\r\n\t\t\t\tholes.forEach( h => {\r\n\r\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\r\n\t\t\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\r\n\t\t\t\t\tpath.curves = hole.curves;\r\n\t\t\t\t\tshape.holes.push( path );\r\n\r\n\t\t\t\t} );\r\n\t\t\t\tshapesToReturn.push( shape );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn shapesToReturn;\r\n\r\n\t}\r\n\r\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\r\n\r\n\t\t// Param width: Stroke width\r\n\t\t// Param color: As returned by THREE.Color.getStyle()\r\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\r\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\r\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\r\n\t\t// Returns style object\r\n\r\n\t\twidth = width !== undefined ? width : 1;\r\n\t\tcolor = color !== undefined ? color : '#000';\r\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\r\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\r\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\r\n\r\n\t\treturn {\r\n\t\t\tstrokeColor: color,\r\n\t\t\tstrokeWidth: width,\r\n\t\t\tstrokeLineJoin: lineJoin,\r\n\t\t\tstrokeLineCap: lineCap,\r\n\t\t\tstrokeMiterLimit: miterLimit\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\r\n\r\n\t\t// Generates a stroke with some width around the given path.\r\n\t\t// The path can be open or closed (last point equals to first point)\r\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\r\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\r\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\r\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\r\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\r\n\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\r\n\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\r\n\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\r\n\r\n\t\t// This function can be called to update existing arrays or buffers.\r\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\r\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\r\n\t\t// Returns number of written vertices / normals / uvs pairs\r\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\r\n\t\t// 'normals' and 'uvs' buffers are optional\r\n\r\n\t\tconst tempV2_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV2_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV2_3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV2_4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV2_5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV2_6 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst tempV2_7 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst lastPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst lastPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst point0L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst point0R = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst currentPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst currentPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst nextPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst nextPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst innerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\t\tconst outerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\r\n\r\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\r\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\r\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\r\n\r\n\t\t// First ensure there are no duplicated points\r\n\t\tpoints = removeDuplicatedPoints( points );\r\n\r\n\t\tconst numPoints = points.length;\r\n\r\n\t\tif ( numPoints < 2 ) return 0;\r\n\r\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\r\n\r\n\t\tlet currentPoint;\r\n\t\tlet previousPoint = points[ 0 ];\r\n\t\tlet nextPoint;\r\n\r\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\r\n\r\n\t\tconst deltaU = 1 / ( numPoints - 1 );\r\n\t\tlet u0 = 0, u1;\r\n\r\n\t\tlet innerSideModified;\r\n\t\tlet joinIsOnLeftSide;\r\n\t\tlet isMiter;\r\n\t\tlet initialJoinIsOnLeftSide = false;\r\n\r\n\t\tlet numVertices = 0;\r\n\t\tlet currentCoordinate = vertexOffset * 3;\r\n\t\tlet currentCoordinateUV = vertexOffset * 2;\r\n\r\n\t\t// Get initial left and right stroke points\r\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\r\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\r\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\r\n\t\tpoint0L.copy( lastPointL );\r\n\t\tpoint0R.copy( lastPointR );\r\n\r\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\r\n\r\n\t\t\tcurrentPoint = points[ iPoint ];\r\n\r\n\t\t\t// Get next point\r\n\t\t\tif ( iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\tif ( isClosed ) {\r\n\r\n\t\t\t\t\t// Skip duplicated initial point\r\n\t\t\t\t\tnextPoint = points[ 1 ];\r\n\r\n\t\t\t\t} else nextPoint = undefined;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Normal of previous segment in tempV2_1\r\n\t\t\tconst normal1 = tempV2_1;\r\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\r\n\r\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\r\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\tu1 = u0 + deltaU;\r\n\r\n\t\t\tinnerSideModified = false;\r\n\r\n\t\t\tif ( nextPoint !== undefined ) {\r\n\r\n\t\t\t\t// Normal of next segment in tempV2_2\r\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\r\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\t\tjoinIsOnLeftSide = true;\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\r\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\r\n\r\n\t\t\t\t\tjoinIsOnLeftSide = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\r\n\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\r\n\t\t\t\ttempV2_3.normalize();\r\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\r\n\r\n\t\t\t\t// If path is straight, don't create join\r\n\t\t\t\tif ( dot > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// Compute inner and outer segment intersections\r\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\r\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\r\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\r\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\r\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\r\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\r\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\r\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\r\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\r\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\r\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\r\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\r\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\r\n\r\n\t\t\t\t\t\tinnerSideModified = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\r\n\t\t\t\t\tinnerPoint.add( currentPoint );\r\n\r\n\t\t\t\t\tisMiter = false;\r\n\r\n\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\r\n\r\n\t\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\r\n\r\n\t\t\t\t\t\tcase 'bevel':\r\n\r\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t// Join triangles\r\n\r\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'miter':\r\n\t\t\t\t\t\tcase 'miter-clip':\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\r\n\r\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\r\n\r\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// Miter join segment triangles\r\n\r\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tisMiter = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\r\n\r\n\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\r\n\r\n\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\t// Start line endcap\r\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Increment loop variables\r\n\r\n\t\t\tu0 = u1;\r\n\r\n\t\t\tpreviousPoint = currentPoint;\r\n\r\n\t\t\tlastPointL.copy( nextPointL );\r\n\t\t\tlastPointR.copy( nextPointR );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! isClosed ) {\r\n\r\n\t\t\t// Ending line endcap\r\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\r\n\r\n\t\t} else if ( innerSideModified && vertices ) {\r\n\r\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\r\n\r\n\t\t\tlet lastOuter = outerPoint;\r\n\t\t\tlet lastInner = innerPoint;\r\n\r\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tlastOuter = innerPoint;\r\n\t\t\t\tlastInner = outerPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn numVertices;\r\n\r\n\t\t// -- End of algorithm\r\n\r\n\t\t// -- Functions\r\n\r\n\t\tfunction getNormal( p1, p2, result ) {\r\n\r\n\t\t\tresult.subVectors( p2, p1 );\r\n\t\t\treturn result.set( - result.y, result.x ).normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( position, u, v ) {\r\n\r\n\t\t\tif ( vertices ) {\r\n\r\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\r\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\r\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\r\n\r\n\t\t\t\tif ( normals ) {\r\n\r\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentCoordinate += 3;\r\n\r\n\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\r\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\r\n\r\n\t\t\t\t\tcurrentCoordinateUV += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnumVertices += 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\r\n\r\n\t\t\t// param p1, p2: Points in the circle arc.\r\n\t\t\t// p1 and p2 are in clockwise direction.\r\n\r\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\r\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\r\n\r\n\t\t\tlet angle = Math.PI;\r\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\r\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\r\n\r\n\t\t\tangle /= arcDivisions;\r\n\r\n\t\t\ttempV2_3.copy( p1 );\r\n\r\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\r\n\r\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\r\n\r\n\t\t\t\taddVertex( tempV2_3, u, v );\r\n\t\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\taddVertex( p2, u, v );\r\n\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentTriangles() {\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( currentPointL, u1, 1 );\r\n\t\t\taddVertex( currentPointR, u1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t// Optimized segment + bevel triangles\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\r\n\r\n\t\t\t// param center: End point of the path\r\n\t\t\t// param p1, p2: Left and right cap points\r\n\r\n\t\t\tswitch ( style.strokeLineCap ) {\r\n\r\n\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'square':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\tconst vl = vertices.length;\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'butt':\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t// Nothing to do here\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction removeDuplicatedPoints( points ) {\r\n\r\n\t\t\t// Creates a new array if necessary with duplicated points removed.\r\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\r\n\r\n\t\t\tlet dupPoints = false;\r\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\r\n\r\n\t\t\t\t\tdupPoints = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! dupPoints ) return points;\r\n\r\n\t\t\tconst newPoints = [];\r\n\t\t\tnewPoints.push( points[ 0 ] );\r\n\r\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\r\n\r\n\t\t\t\t\tnewPoints.push( points[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\r\n\r\n\t\t\treturn newPoints;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9TVkdMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFjZTtBQUNmO0FBQ0Esd0JBQXdCLGlEQUFjO0FBQ3RDO0FBQ0Esd0JBQXdCLHlDQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVM7QUFDN0I7QUFDQSxxQkFBcUIsMENBQU87QUFDNUIsdUJBQXVCLDBDQUFPO0FBQzlCO0FBQ0EsMEJBQTBCLDBDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVDQUFJO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQUk7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFPO0FBQzFCLG1CQUFtQiwwQ0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsV0FBVywwQ0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQU87QUFDcEMsNkJBQTZCLDBDQUFPO0FBQ3BDLDZCQUE2QiwwQ0FBTztBQUNwQyw2QkFBNkIsMENBQU87QUFDcEMscUJBQXFCLDBDQUFPO0FBQzVCLHFCQUFxQiwwQ0FBTztBQUM1QjtBQUNBLCtCQUErQiwwQ0FBTztBQUN0QztBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQXlEO0FBQ3hGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUFPO0FBQ3hDO0FBQ0E7QUFDQSwwQkFBMEIsMENBQU8sMkNBQTJDLDBDQUFPO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3Qyw2Q0FBVSwwREFBMEQsdUNBQUksTUFBTSwwQ0FBTyxvQkFBb0IsMENBQU87QUFDcEs7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3Q0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFjO0FBQ3JDLHlDQUF5Qyx5REFBc0I7QUFDL0QsdUNBQXVDLHlEQUFzQjtBQUM3RCxtQ0FBbUMseURBQXNCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIseUJBQXlCLDBDQUFPO0FBQ2hDLHlCQUF5QiwwQ0FBTztBQUNoQyxzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDBDQUFPO0FBQzdCLDRCQUE0QiwwQ0FBTztBQUNuQyw0QkFBNEIsMENBQU87QUFDbkMseUJBQXlCLDBDQUFPO0FBQ2hDLHlCQUF5QiwwQ0FBTztBQUNoQyx5QkFBeUIsMENBQU87QUFDaEMseUJBQXlCLDBDQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvU1ZHTG9hZGVyLmpzPzUxYzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuXHRCb3gyLFxyXG5cdEJ1ZmZlckdlb21ldHJ5LFxyXG5cdEZpbGVMb2FkZXIsXHJcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRMb2FkZXIsXHJcblx0TWF0cml4MyxcclxuXHRQYXRoLFxyXG5cdFNoYXBlLFxyXG5cdFNoYXBlUGF0aCxcclxuXHRTaGFwZVV0aWxzLFxyXG5cdFNSR0JDb2xvclNwYWNlLFxyXG5cdFZlY3RvcjIsXHJcblx0VmVjdG9yM1xyXG59IGZyb20gJ3RocmVlJztcclxuXHJcbmNvbnN0IENPTE9SX1NQQUNFX1NWRyA9IFNSR0JDb2xvclNwYWNlO1xyXG5cclxuY2xhc3MgU1ZHTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0XHQvLyBEZWZhdWx0IGRvdHMgcGVyIGluY2hcclxuXHRcdHRoaXMuZGVmYXVsdERQSSA9IDkwO1xyXG5cclxuXHRcdC8vIEFjY2VwdGVkIHVuaXRzOiAnbW0nLCAnY20nLCAnaW4nLCAncHQnLCAncGMnLCAncHgnXHJcblx0XHR0aGlzLmRlZmF1bHRVbml0ID0gJ3B4JztcclxuXHJcblx0fVxyXG5cclxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xyXG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcclxuXHJcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlKCB0ZXh0ICkge1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZU5vZGUoIG5vZGUsIHN0eWxlICkge1xyXG5cclxuXHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gZ2V0Tm9kZVRyYW5zZm9ybSggbm9kZSApO1xyXG5cclxuXHRcdFx0bGV0IGlzRGVmc05vZGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGxldCBwYXRoID0gbnVsbDtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG5vZGUubm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3N2Zyc6XHJcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnc3R5bGUnOlxyXG5cdFx0XHRcdFx0cGFyc2VDU1NTdHlsZXNoZWV0KCBub2RlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZyc6XHJcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncGF0aCc6XHJcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XHJcblx0XHRcdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAnZCcgKSApIHBhdGggPSBwYXJzZVBhdGhOb2RlKCBub2RlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncmVjdCc6XHJcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XHJcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VSZWN0Tm9kZSggbm9kZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3BvbHlnb24nOlxyXG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xyXG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlUG9seWdvbk5vZGUoIG5vZGUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdwb2x5bGluZSc6XHJcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XHJcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VQb2x5bGluZU5vZGUoIG5vZGUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdjaXJjbGUnOlxyXG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xyXG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlQ2lyY2xlTm9kZSggbm9kZSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2VsbGlwc2UnOlxyXG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xyXG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlRWxsaXBzZU5vZGUoIG5vZGUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdsaW5lJzpcclxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcclxuXHRcdFx0XHRcdHBhdGggPSBwYXJzZUxpbmVOb2RlKCBub2RlICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnZGVmcyc6XHJcblx0XHRcdFx0XHRpc0RlZnNOb2RlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICd1c2UnOlxyXG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGhyZWYgPSBub2RlLmdldEF0dHJpYnV0ZU5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJyApIHx8ICcnO1xyXG5cdFx0XHRcdFx0Y29uc3QgdXNlZE5vZGVJZCA9IGhyZWYuc3Vic3RyaW5nKCAxICk7XHJcblx0XHRcdFx0XHRjb25zdCB1c2VkTm9kZSA9IG5vZGUudmlld3BvcnRFbGVtZW50LmdldEVsZW1lbnRCeUlkKCB1c2VkTm9kZUlkICk7XHJcblx0XHRcdFx0XHRpZiAoIHVzZWROb2RlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cGFyc2VOb2RlKCB1c2VkTm9kZSwgc3R5bGUgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnU1ZHTG9hZGVyOiBcXCd1c2Ugbm9kZVxcJyByZWZlcmVuY2VzIG5vbi1leGlzdGVudCBub2RlIGlkOiAnICsgdXNlZE5vZGVJZCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBub2RlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHBhdGggKSB7XHJcblxyXG5cdFx0XHRcdGlmICggc3R5bGUuZmlsbCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlLmZpbGwgIT09ICdub25lJyApIHtcclxuXHJcblx0XHRcdFx0XHRwYXRoLmNvbG9yLnNldFN0eWxlKCBzdHlsZS5maWxsLCBDT0xPUl9TUEFDRV9TVkcgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0cmFuc2Zvcm1QYXRoKCBwYXRoLCBjdXJyZW50VHJhbnNmb3JtICk7XHJcblxyXG5cdFx0XHRcdHBhdGhzLnB1c2goIHBhdGggKTtcclxuXHJcblx0XHRcdFx0cGF0aC51c2VyRGF0YSA9IHsgbm9kZTogbm9kZSwgc3R5bGU6IHN0eWxlIH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBjaGlsZE5vZGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggaXNEZWZzTm9kZSAmJiBub2RlLm5vZGVOYW1lICE9PSAnc3R5bGUnICYmIG5vZGUubm9kZU5hbWUgIT09ICdkZWZzJyApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBJZ25vcmUgZXZlcnl0aGluZyBpbiBkZWZzIGV4Y2VwdCBDU1Mgc3R5bGUgZGVmaW5pdGlvbnNcclxuXHRcdFx0XHRcdC8vIGFuZCBuZXN0ZWQgZGVmcywgYmVjYXVzZSBpdCBpcyBPSyBieSB0aGUgc3RhbmRhcmQgdG8gaGF2ZVxyXG5cdFx0XHRcdFx0Ly8gPHN0eWxlLz4gdGhlcmUuXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXJzZU5vZGUoIG5vZGUsIHN0eWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0aWYgKCB0cmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0XHRcdHRyYW5zZm9ybVN0YWNrLnBvcCgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5jb3B5KCB0cmFuc2Zvcm1TdGFja1sgdHJhbnNmb3JtU3RhY2subGVuZ3RoIC0gMSBdICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5pZGVudGl0eSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlUGF0aE5vZGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRjb25zdCBjb250cm9sID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRcdGNvbnN0IGZpcnN0UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRsZXQgaXNGaXJzdFBvaW50ID0gdHJ1ZTtcclxuXHRcdFx0bGV0IGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Y29uc3QgZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnZCcgKTtcclxuXHJcblx0XHRcdGlmICggZCA9PT0gJycgfHwgZCA9PT0gJ25vbmUnICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggZCApO1xyXG5cclxuXHRcdFx0Y29uc3QgY29tbWFuZHMgPSBkLm1hdGNoKCAvW2EtZGYtel1bXmEtZGYtel0qL2lnICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjb21tYW5kcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gY29tbWFuZHNbIGkgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgdHlwZSA9IGNvbW1hbmQuY2hhckF0KCAwICk7XHJcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNvbW1hbmQuc2xpY2UoIDEgKS50cmltKCk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNGaXJzdFBvaW50ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGRvU2V0Rmlyc3RQb2ludCA9IHRydWU7XHJcblx0XHRcdFx0XHRpc0ZpcnN0UG9pbnQgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgbnVtYmVycztcclxuXHJcblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdNJzpcclxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMSBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCBwb2ludC54LCBwb2ludC55ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdIJzpcclxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogXTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XHJcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1YnOlxyXG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcclxuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnTCc6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAwIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAxIF07XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xyXG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDJzpcclxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDQgXSxcclxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyA1IF1cclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IG51bWJlcnNbIGogKyAyIF07XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gbnVtYmVyc1sgaiArIDMgXTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDQgXTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDUgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1MnOlxyXG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcclxuXHRcdFx0XHRcdFx0XHRcdGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApLFxyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICksXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBudW1iZXJzWyBqICsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IG51bWJlcnNbIGogKyAxIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAyIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAzIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdRJzpcclxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBudW1iZXJzWyBqICsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IG51bWJlcnNbIGogKyAxIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAyIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAzIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdUJzpcclxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCByeCA9IGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJ5ID0gZ2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICk7XHJcblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxyXG5cdFx0XHRcdFx0XHRcdFx0cngsXHJcblx0XHRcdFx0XHRcdFx0XHRyeSxcclxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAwIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSByeDtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSByeTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDAgXTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ0EnOlxyXG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEsIFsgMywgNCBdLCA3ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA3ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBza2lwIGNvbW1hbmQgaWYgc3RhcnQgcG9pbnQgPT0gZW5kIHBvaW50XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBudW1iZXJzWyBqICsgNSBdID09IHBvaW50LnggJiYgbnVtYmVyc1sgaiArIDYgXSA9PSBwb2ludC55ICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDUgXTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDYgXTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XHJcblx0XHRcdFx0XHRcdFx0cGFyc2VBcmNDb21tYW5kKFxyXG5cdFx0XHRcdFx0XHRcdFx0cGF0aCwgbnVtYmVyc1sgaiBdLCBudW1iZXJzWyBqICsgMSBdLCBudW1iZXJzWyBqICsgMiBdLCBudW1iZXJzWyBqICsgMyBdLCBudW1iZXJzWyBqICsgNCBdLCBzdGFydCwgcG9pbnRcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnbSc6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDEgXTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRwYXRoLm1vdmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnaCc6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcclxuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAndic6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcclxuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnbCc6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDEgXTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XHJcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDIgXSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyA0IF0sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDUgXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAyIF07XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueSArIG51bWJlcnNbIGogKyAzIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgNCBdO1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDUgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ3MnOlxyXG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcclxuXHRcdFx0XHRcdFx0XHRcdGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApLFxyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICksXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDMgXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueSArIG51bWJlcnNbIGogKyAxIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMiBdO1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ3EnOlxyXG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDIgXSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAyIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAndCc6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgcnggPSBnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKTtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCByeSA9IGdldFJlZmxlY3Rpb24oIHBvaW50LnksIGNvbnRyb2wueSApO1xyXG5cdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhcclxuXHRcdFx0XHRcdFx0XHRcdHJ4LFxyXG5cdFx0XHRcdFx0XHRcdFx0cnksXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSByeDtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSByeTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XHJcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnYSc6XHJcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSwgWyAzLCA0IF0sIDcgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHNraXAgY29tbWFuZCBpZiBubyBkaXNwbGFjZW1lbnRcclxuXHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlcnNbIGogKyA1IF0gPT0gMCAmJiBudW1iZXJzWyBqICsgNiBdID09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDUgXTtcclxuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyA2IF07XHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcclxuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xyXG5cdFx0XHRcdFx0XHRcdHBhcnNlQXJjQ29tbWFuZChcclxuXHRcdFx0XHRcdFx0XHRcdHBhdGgsIG51bWJlcnNbIGogXSwgbnVtYmVyc1sgaiArIDEgXSwgbnVtYmVyc1sgaiArIDIgXSwgbnVtYmVyc1sgaiArIDMgXSwgbnVtYmVyc1sgaiArIDQgXSwgc3RhcnQsIHBvaW50XHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1onOlxyXG5cdFx0XHRcdFx0Y2FzZSAneic6XHJcblx0XHRcdFx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggcGF0aC5jdXJyZW50UGF0aC5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQgcG9pbnQgdG8gYmVnaW5uaW5nIG9mIFBhdGhcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5jb3B5KCBmaXJzdFBvaW50ICk7XHJcblx0XHRcdFx0XHRcdFx0cGF0aC5jdXJyZW50UGF0aC5jdXJyZW50UG9pbnQuY29weSggcG9pbnQgKTtcclxuXHRcdFx0XHRcdFx0XHRpc0ZpcnN0UG9pbnQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBjb21tYW5kICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIHBhcnNlRmxvYXRzKCBkYXRhICksIHBhcnNlRmxvYXRzKCBkYXRhICkubGVuZ3RoICApXHJcblxyXG5cdFx0XHRcdGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlQ1NTU3R5bGVzaGVldCggbm9kZSApIHtcclxuXHJcblx0XHRcdGlmICggISBub2RlLnNoZWV0IHx8ICEgbm9kZS5zaGVldC5jc3NSdWxlcyB8fCAhIG5vZGUuc2hlZXQuY3NzUnVsZXMubGVuZ3RoICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbm9kZS5zaGVldC5jc3NSdWxlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN0eWxlc2hlZXQgPSBub2RlLnNoZWV0LmNzc1J1bGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggc3R5bGVzaGVldC50eXBlICE9PSAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNlbGVjdG9yTGlzdCA9IHN0eWxlc2hlZXQuc2VsZWN0b3JUZXh0XHJcblx0XHRcdFx0XHQuc3BsaXQoIC8sL2dtIClcclxuXHRcdFx0XHRcdC5maWx0ZXIoIEJvb2xlYW4gKVxyXG5cdFx0XHRcdFx0Lm1hcCggaSA9PiBpLnRyaW0oKSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBzZWxlY3Rvckxpc3QubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFJlbW92ZSBlbXB0eSBydWxlc1xyXG5cdFx0XHRcdFx0Y29uc3QgZGVmaW5pdGlvbnMgPSBPYmplY3QuZnJvbUVudHJpZXMoXHJcblx0XHRcdFx0XHRcdE9iamVjdC5lbnRyaWVzKCBzdHlsZXNoZWV0LnN0eWxlICkuZmlsdGVyKCAoIFsgLCB2IF0gKSA9PiB2ICE9PSAnJyApXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdHN0eWxlc2hlZXRzWyBzZWxlY3Rvckxpc3RbIGogXSBdID0gT2JqZWN0LmFzc2lnbihcclxuXHRcdFx0XHRcdFx0c3R5bGVzaGVldHNbIHNlbGVjdG9yTGlzdFsgaiBdIF0gfHwge30sXHJcblx0XHRcdFx0XHRcdGRlZmluaXRpb25zXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcclxuXHRcdCAqIGh0dHBzOi8vbW9ydG9yYXkuY29tLzIwMTcvMDIvMTYvcmVuZGVyaW5nLWFuLXN2Zy1lbGxpcHRpY2FsLWFyYy1hcy1iZXppZXItY3VydmVzLyBBcHBlbmRpeDogRW5kcG9pbnQgdG8gY2VudGVyIGFyYyBjb252ZXJzaW9uXHJcblx0XHQgKiBGcm9tXHJcblx0XHQgKiByeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHlcclxuXHRcdCAqIFRvXHJcblx0XHQgKiBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvblxyXG5cdFx0ICovXHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VBcmNDb21tYW5kKCBwYXRoLCByeCwgcnksIHhfYXhpc19yb3RhdGlvbiwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJ4ID09IDAgfHwgcnkgPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gZHJhdyBhIGxpbmUgaWYgZWl0aGVyIG9mIHRoZSByYWRpaSA9PSAwXHJcblx0XHRcdFx0cGF0aC5saW5lVG8oIGVuZC54LCBlbmQueSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHhfYXhpc19yb3RhdGlvbiA9IHhfYXhpc19yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcblxyXG5cdFx0XHQvLyBFbnN1cmUgcmFkaWkgYXJlIHBvc2l0aXZlXHJcblx0XHRcdHJ4ID0gTWF0aC5hYnMoIHJ4ICk7XHJcblx0XHRcdHJ5ID0gTWF0aC5hYnMoIHJ5ICk7XHJcblxyXG5cdFx0XHQvLyBDb21wdXRlICh4MScsIHkxJylcclxuXHRcdFx0Y29uc3QgZHgyID0gKCBzdGFydC54IC0gZW5kLnggKSAvIDIuMDtcclxuXHRcdFx0Y29uc3QgZHkyID0gKCBzdGFydC55IC0gZW5kLnkgKSAvIDIuMDtcclxuXHRcdFx0Y29uc3QgeDFwID0gTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogZHgyICsgTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogZHkyO1xyXG5cdFx0XHRjb25zdCB5MXAgPSAtIE1hdGguc2luKCB4X2F4aXNfcm90YXRpb24gKSAqIGR4MiArIE1hdGguY29zKCB4X2F4aXNfcm90YXRpb24gKSAqIGR5MjtcclxuXHJcblx0XHRcdC8vIENvbXB1dGUgKGN4JywgY3knKVxyXG5cdFx0XHRsZXQgcnhzID0gcnggKiByeDtcclxuXHRcdFx0bGV0IHJ5cyA9IHJ5ICogcnk7XHJcblx0XHRcdGNvbnN0IHgxcHMgPSB4MXAgKiB4MXA7XHJcblx0XHRcdGNvbnN0IHkxcHMgPSB5MXAgKiB5MXA7XHJcblxyXG5cdFx0XHQvLyBFbnN1cmUgcmFkaWkgYXJlIGxhcmdlIGVub3VnaFxyXG5cdFx0XHRjb25zdCBjciA9IHgxcHMgLyByeHMgKyB5MXBzIC8gcnlzO1xyXG5cclxuXHRcdFx0aWYgKCBjciA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHNjYWxlIHVwIHJ4LHJ5IGVxdWFsbHkgc28gY3IgPT0gMVxyXG5cdFx0XHRcdGNvbnN0IHMgPSBNYXRoLnNxcnQoIGNyICk7XHJcblx0XHRcdFx0cnggPSBzICogcng7XHJcblx0XHRcdFx0cnkgPSBzICogcnk7XHJcblx0XHRcdFx0cnhzID0gcnggKiByeDtcclxuXHRcdFx0XHRyeXMgPSByeSAqIHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZHEgPSAoIHJ4cyAqIHkxcHMgKyByeXMgKiB4MXBzICk7XHJcblx0XHRcdGNvbnN0IHBxID0gKCByeHMgKiByeXMgLSBkcSApIC8gZHE7XHJcblx0XHRcdGxldCBxID0gTWF0aC5zcXJ0KCBNYXRoLm1heCggMCwgcHEgKSApO1xyXG5cdFx0XHRpZiAoIGxhcmdlX2FyY19mbGFnID09PSBzd2VlcF9mbGFnICkgcSA9IC0gcTtcclxuXHRcdFx0Y29uc3QgY3hwID0gcSAqIHJ4ICogeTFwIC8gcnk7XHJcblx0XHRcdGNvbnN0IGN5cCA9IC0gcSAqIHJ5ICogeDFwIC8gcng7XHJcblxyXG5cdFx0XHQvLyBTdGVwIDM6IENvbXB1dGUgKGN4LCBjeSkgZnJvbSAoY3gnLCBjeScpXHJcblx0XHRcdGNvbnN0IGN4ID0gTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogY3hwIC0gTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogY3lwICsgKCBzdGFydC54ICsgZW5kLnggKSAvIDI7XHJcblx0XHRcdGNvbnN0IGN5ID0gTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogY3hwICsgTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogY3lwICsgKCBzdGFydC55ICsgZW5kLnkgKSAvIDI7XHJcblxyXG5cdFx0XHQvLyBTdGVwIDQ6IENvbXB1dGUgzrgxIGFuZCDOlM64XHJcblx0XHRcdGNvbnN0IHRoZXRhID0gc3ZnQW5nbGUoIDEsIDAsICggeDFwIC0gY3hwICkgLyByeCwgKCB5MXAgLSBjeXAgKSAvIHJ5ICk7XHJcblx0XHRcdGNvbnN0IGRlbHRhID0gc3ZnQW5nbGUoICggeDFwIC0gY3hwICkgLyByeCwgKCB5MXAgLSBjeXAgKSAvIHJ5LCAoIC0geDFwIC0gY3hwICkgLyByeCwgKCAtIHkxcCAtIGN5cCApIC8gcnkgKSAlICggTWF0aC5QSSAqIDIgKTtcclxuXHJcblx0XHRcdHBhdGguY3VycmVudFBhdGguYWJzZWxsaXBzZSggY3gsIGN5LCByeCwgcnksIHRoZXRhLCB0aGV0YSArIGRlbHRhLCBzd2VlcF9mbGFnID09PSAwLCB4X2F4aXNfcm90YXRpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3ZnQW5nbGUoIHV4LCB1eSwgdngsIHZ5ICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XHJcblx0XHRcdGNvbnN0IGxlbiA9IE1hdGguc3FydCggdXggKiB1eCArIHV5ICogdXkgKSAqIE1hdGguc3FydCggdnggKiB2eCArIHZ5ICogdnkgKTtcclxuXHRcdFx0bGV0IGFuZyA9IE1hdGguYWNvcyggTWF0aC5tYXgoIC0gMSwgTWF0aC5taW4oIDEsIGRvdCAvIGxlbiApICkgKTsgLy8gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLCBzbGlnaHRseSBvdmVyIHZhbHVlcyBhcHBlYXJcclxuXHRcdFx0aWYgKCAoIHV4ICogdnkgLSB1eSAqIHZ4ICkgPCAwICkgYW5nID0gLSBhbmc7XHJcblx0XHRcdHJldHVybiBhbmc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qXHJcblx0XHQqIEFjY29yZGluZyB0byBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50UlhBdHRyaWJ1dGVcclxuXHRcdCogcm91bmRlZCBjb3JuZXIgc2hvdWxkIGJlIHJlbmRlcmVkIHRvIGVsbGlwdGljYWwgYXJjLCBidXQgYmV6aWVyIGN1cnZlIGRvZXMgdGhlIGpvYiB3ZWxsIGVub3VnaFxyXG5cdFx0Ki9cclxuXHRcdGZ1bmN0aW9uIHBhcnNlUmVjdE5vZGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd4JyApIHx8IDAgKTtcclxuXHRcdFx0Y29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneScgKSB8fCAwICk7XHJcblx0XHRcdGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeCcgKSB8fCBub2RlLmdldEF0dHJpYnV0ZSggJ3J5JyApIHx8IDAgKTtcclxuXHRcdFx0Y29uc3QgcnkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3J5JyApIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCAncngnICkgfHwgMCApO1xyXG5cdFx0XHRjb25zdCB3ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd3aWR0aCcgKSApO1xyXG5cdFx0XHRjb25zdCBoID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdoZWlnaHQnICkgKTtcclxuXHJcblx0XHRcdC8vIEVsbGlwc2UgYXJjIHRvIEJlemllciBhcHByb3hpbWF0aW9uIENvZWZmaWNpZW50IChJbnZlcnNlZCkuIFNlZTpcclxuXHRcdFx0Ly8gaHR0cHM6Ly9zcGVuY2VybW9ydGVuc2VuLmNvbS9hcnRpY2xlcy9iZXppZXItY2lyY2xlL1xyXG5cdFx0XHRjb25zdCBiY2kgPSAxIC0gMC41NTE5MTUwMjQ0OTQ7XHJcblxyXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xyXG5cclxuXHRcdFx0Ly8gdG9wIGxlZnRcclxuXHRcdFx0cGF0aC5tb3ZlVG8oIHggKyByeCwgeSApO1xyXG5cclxuXHRcdFx0Ly8gdG9wIHJpZ2h0XHJcblx0XHRcdHBhdGgubGluZVRvKCB4ICsgdyAtIHJ4LCB5ICk7XHJcblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcclxuXHRcdFx0XHRcdHggKyB3IC0gcnggKiBiY2ksXHJcblx0XHRcdFx0XHR5LFxyXG5cdFx0XHRcdFx0eCArIHcsXHJcblx0XHRcdFx0XHR5ICsgcnkgKiBiY2ksXHJcblx0XHRcdFx0XHR4ICsgdyxcclxuXHRcdFx0XHRcdHkgKyByeVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBib3R0b20gcmlnaHRcclxuXHRcdFx0cGF0aC5saW5lVG8oIHggKyB3LCB5ICsgaCAtIHJ5ICk7XHJcblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcclxuXHRcdFx0XHRcdHggKyB3LFxyXG5cdFx0XHRcdFx0eSArIGggLSByeSAqIGJjaSxcclxuXHRcdFx0XHRcdHggKyB3IC0gcnggKiBiY2ksXHJcblx0XHRcdFx0XHR5ICsgaCxcclxuXHRcdFx0XHRcdHggKyB3IC0gcngsXHJcblx0XHRcdFx0XHR5ICsgaFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBib3R0b20gbGVmdFxyXG5cdFx0XHRwYXRoLmxpbmVUbyggeCArIHJ4LCB5ICsgaCApO1xyXG5cdFx0XHRpZiAoIHJ4ICE9PSAwIHx8IHJ5ICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXHJcblx0XHRcdFx0XHR4ICsgcnggKiBiY2ksXHJcblx0XHRcdFx0XHR5ICsgaCxcclxuXHRcdFx0XHRcdHgsXHJcblx0XHRcdFx0XHR5ICsgaCAtIHJ5ICogYmNpLFxyXG5cdFx0XHRcdFx0eCxcclxuXHRcdFx0XHRcdHkgKyBoIC0gcnlcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmFjayB0byB0b3AgbGVmdFxyXG5cdFx0XHRwYXRoLmxpbmVUbyggeCwgeSArIHJ5ICk7XHJcblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyggeCwgeSArIHJ5ICogYmNpLCB4ICsgcnggKiBiY2ksIHksIHggKyByeCwgeSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlUG9seWdvbk5vZGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBpdGVyYXRvciggbWF0Y2gsIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBhICk7XHJcblx0XHRcdFx0Y29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGIgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRwYXRoLm1vdmVUbyggeCwgeSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5kZXggKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCByZWdleCA9IC8oWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pKD86LHxcXHMpKFsrLV0/XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KS9nO1xyXG5cclxuXHRcdFx0Y29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcclxuXHJcblx0XHRcdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdFx0XHRub2RlLmdldEF0dHJpYnV0ZSggJ3BvaW50cycgKS5yZXBsYWNlKCByZWdleCwgaXRlcmF0b3IgKTtcclxuXHJcblx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcclxuXHJcblx0XHRcdHJldHVybiBwYXRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZVBvbHlsaW5lTm9kZSggbm9kZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGl0ZXJhdG9yKCBtYXRjaCwgYSwgYiApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGEgKTtcclxuXHRcdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbmRleCArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHJlZ2V4ID0gLyhbKy1dP1xcZCpcXC4/XFxkKyg/OmVbKy1dP1xcZCspPykoPzosfFxccykoWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pL2c7XHJcblxyXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xyXG5cclxuXHRcdFx0bGV0IGluZGV4ID0gMDtcclxuXHJcblx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAncG9pbnRzJyApLnJlcGxhY2UoIHJlZ2V4LCBpdGVyYXRvciApO1xyXG5cclxuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSBmYWxzZTtcclxuXHJcblx0XHRcdHJldHVybiBwYXRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZUNpcmNsZU5vZGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeCcgKSB8fCAwICk7XHJcblx0XHRcdGNvbnN0IHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N5JyApIHx8IDAgKTtcclxuXHRcdFx0Y29uc3QgciA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncicgKSB8fCAwICk7XHJcblxyXG5cdFx0XHRjb25zdCBzdWJwYXRoID0gbmV3IFBhdGgoKTtcclxuXHRcdFx0c3VicGF0aC5hYnNhcmMoIHgsIHksIHIsIDAsIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xyXG5cdFx0XHRwYXRoLnN1YlBhdGhzLnB1c2goIHN1YnBhdGggKTtcclxuXHJcblx0XHRcdHJldHVybiBwYXRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZUVsbGlwc2VOb2RlKCBub2RlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnY3gnICkgfHwgMCApO1xyXG5cdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeScgKSB8fCAwICk7XHJcblx0XHRcdGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeCcgKSB8fCAwICk7XHJcblx0XHRcdGNvbnN0IHJ5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeScgKSB8fCAwICk7XHJcblxyXG5cdFx0XHRjb25zdCBzdWJwYXRoID0gbmV3IFBhdGgoKTtcclxuXHRcdFx0c3VicGF0aC5hYnNlbGxpcHNlKCB4LCB5LCByeCwgcnksIDAsIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xyXG5cdFx0XHRwYXRoLnN1YlBhdGhzLnB1c2goIHN1YnBhdGggKTtcclxuXHJcblx0XHRcdHJldHVybiBwYXRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZUxpbmVOb2RlKCBub2RlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeDEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gxJyApIHx8IDAgKTtcclxuXHRcdFx0Y29uc3QgeTEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3kxJyApIHx8IDAgKTtcclxuXHRcdFx0Y29uc3QgeDIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gyJyApIHx8IDAgKTtcclxuXHRcdFx0Y29uc3QgeTIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3kyJyApIHx8IDAgKTtcclxuXHJcblx0XHRcdGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XHJcblx0XHRcdHBhdGgubW92ZVRvKCB4MSwgeTEgKTtcclxuXHRcdFx0cGF0aC5saW5lVG8oIHgyLCB5MiApO1xyXG5cdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKSB7XHJcblxyXG5cdFx0XHRzdHlsZSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzdHlsZSApOyAvLyBjbG9uZSBzdHlsZVxyXG5cclxuXHRcdFx0bGV0IHN0eWxlc2hlZXRTdHlsZXMgPSB7fTtcclxuXHJcblx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICdjbGFzcycgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2xhc3NTZWxlY3RvcnMgPSBub2RlLmdldEF0dHJpYnV0ZSggJ2NsYXNzJyApXHJcblx0XHRcdFx0XHQuc3BsaXQoIC9cXHMvIClcclxuXHRcdFx0XHRcdC5maWx0ZXIoIEJvb2xlYW4gKVxyXG5cdFx0XHRcdFx0Lm1hcCggaSA9PiBpLnRyaW0oKSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGFzc1NlbGVjdG9ycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3R5bGVzaGVldFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oIHN0eWxlc2hlZXRTdHlsZXMsIHN0eWxlc2hlZXRzWyAnLicgKyBjbGFzc1NlbGVjdG9yc1sgaSBdIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ2lkJyApICkge1xyXG5cclxuXHRcdFx0XHRzdHlsZXNoZWV0U3R5bGVzID0gT2JqZWN0LmFzc2lnbiggc3R5bGVzaGVldFN0eWxlcywgc3R5bGVzaGVldHNbICcjJyArIG5vZGUuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gYWRkU3R5bGUoIHN2Z05hbWUsIGpzTmFtZSwgYWRqdXN0RnVuY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYWRqdXN0RnVuY3Rpb24gPT09IHVuZGVmaW5lZCApIGFkanVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gY29weSggdiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHYuc3RhcnRzV2l0aCggJ3VybCcgKSApIGNvbnNvbGUud2FybiggJ1NWR0xvYWRlcjogdXJsIGFjY2VzcyBpbiBhdHRyaWJ1dGVzIGlzIG5vdCBpbXBsZW1lbnRlZC4nICk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHY7XHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoIHN2Z05hbWUgKSApIHN0eWxlWyBqc05hbWUgXSA9IGFkanVzdEZ1bmN0aW9uKCBub2RlLmdldEF0dHJpYnV0ZSggc3ZnTmFtZSApICk7XHJcblx0XHRcdFx0aWYgKCBzdHlsZXNoZWV0U3R5bGVzWyBzdmdOYW1lIF0gKSBzdHlsZVsganNOYW1lIF0gPSBhZGp1c3RGdW5jdGlvbiggc3R5bGVzaGVldFN0eWxlc1sgc3ZnTmFtZSBdICk7XHJcblx0XHRcdFx0aWYgKCBub2RlLnN0eWxlICYmIG5vZGUuc3R5bGVbIHN2Z05hbWUgXSAhPT0gJycgKSBzdHlsZVsganNOYW1lIF0gPSBhZGp1c3RGdW5jdGlvbiggbm9kZS5zdHlsZVsgc3ZnTmFtZSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBjbGFtcCggdiApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KCAwLCBNYXRoLm1pbiggMSwgcGFyc2VGbG9hdFdpdGhVbml0cyggdiApICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHBvc2l0aXZlKCB2ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoIDAsIHBhcnNlRmxvYXRXaXRoVW5pdHMoIHYgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWRkU3R5bGUoICdmaWxsJywgJ2ZpbGwnICk7XHJcblx0XHRcdGFkZFN0eWxlKCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGxPcGFjaXR5JywgY2xhbXAgKTtcclxuXHRcdFx0YWRkU3R5bGUoICdmaWxsLXJ1bGUnLCAnZmlsbFJ1bGUnICk7XHJcblx0XHRcdGFkZFN0eWxlKCAnb3BhY2l0eScsICdvcGFjaXR5JywgY2xhbXAgKTtcclxuXHRcdFx0YWRkU3R5bGUoICdzdHJva2UnLCAnc3Ryb2tlJyApO1xyXG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZU9wYWNpdHknLCBjbGFtcCApO1xyXG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS13aWR0aCcsICdzdHJva2VXaWR0aCcsIHBvc2l0aXZlICk7XHJcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZUxpbmVKb2luJyApO1xyXG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZUxpbmVDYXAnICk7XHJcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlTWl0ZXJMaW1pdCcsIHBvc2l0aXZlICk7XHJcblx0XHRcdGFkZFN0eWxlKCAndmlzaWJpbGl0eScsICd2aXNpYmlsaXR5JyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHN0eWxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI1BhdGhFbGVtZW50SW1wbGVtZW50YXRpb25Ob3Rlc1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFJlZmxlY3Rpb24oIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYSAtICggYiAtIGEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcHB2Zy9zdmctbnVtYmVycyAoTUlUIExpY2Vuc2UpXHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VGbG9hdHMoIGlucHV0LCBmbGFncywgc3RyaWRlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnSW52YWxpZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ2hhcmFjdGVyIGdyb3Vwc1xyXG5cdFx0XHRjb25zdCBSRSA9IHtcclxuXHRcdFx0XHRTRVBBUkFUT1I6IC9bIFxcdFxcclxcblxcLC5cXC0rXS8sXHJcblx0XHRcdFx0V0hJVEVTUEFDRTogL1sgXFx0XFxyXFxuXS8sXHJcblx0XHRcdFx0RElHSVQ6IC9bXFxkXS8sXHJcblx0XHRcdFx0U0lHTjogL1stK10vLFxyXG5cdFx0XHRcdFBPSU5UOiAvXFwuLyxcclxuXHRcdFx0XHRDT01NQTogLywvLFxyXG5cdFx0XHRcdEVYUDogL2UvaSxcclxuXHRcdFx0XHRGTEFHUzogL1swMV0vXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBTdGF0ZXNcclxuXHRcdFx0Y29uc3QgU0VQID0gMDtcclxuXHRcdFx0Y29uc3QgSU5UID0gMTtcclxuXHRcdFx0Y29uc3QgRkxPQVQgPSAyO1xyXG5cdFx0XHRjb25zdCBFWFAgPSAzO1xyXG5cclxuXHRcdFx0bGV0IHN0YXRlID0gU0VQO1xyXG5cdFx0XHRsZXQgc2VlbkNvbW1hID0gdHJ1ZTtcclxuXHRcdFx0bGV0IG51bWJlciA9ICcnLCBleHBvbmVudCA9ICcnO1xyXG5cdFx0XHRjb25zdCByZXN1bHQgPSBbXTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHBhcnRpYWwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKCAnVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCInICsgY3VycmVudCArICdcIiBhdCBpbmRleCAnICsgaSArICcuJyApO1xyXG5cdFx0XHRcdGVycm9yLnBhcnRpYWwgPSBwYXJ0aWFsO1xyXG5cdFx0XHRcdHRocm93IGVycm9yO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbmV3TnVtYmVyKCkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG51bWJlciAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBleHBvbmVudCA9PT0gJycgKSByZXN1bHQucHVzaCggTnVtYmVyKCBudW1iZXIgKSApO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXN1bHQucHVzaCggTnVtYmVyKCBudW1iZXIgKSAqIE1hdGgucG93KCAxMCwgTnVtYmVyKCBleHBvbmVudCApICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRudW1iZXIgPSAnJztcclxuXHRcdFx0XHRleHBvbmVudCA9ICcnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGN1cnJlbnQ7XHJcblx0XHRcdGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudCA9IGlucHV0WyBpIF07XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBmbGFnc1xyXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZmxhZ3MgKSAmJiBmbGFncy5pbmNsdWRlcyggcmVzdWx0Lmxlbmd0aCAlIHN0cmlkZSApICYmIFJFLkZMQUdTLnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZSA9IElOVDtcclxuXHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XHJcblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHBhcnNlIHVudGlsIG5leHQgbnVtYmVyXHJcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gU0VQICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGVhdCB3aGl0ZXNwYWNlXHJcblx0XHRcdFx0XHRpZiAoIFJFLldISVRFU1BBQ0UudGVzdCggY3VycmVudCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHN0YXJ0IG5ldyBudW1iZXJcclxuXHRcdFx0XHRcdGlmICggUkUuRElHSVQudGVzdCggY3VycmVudCApIHx8IFJFLlNJR04udGVzdCggY3VycmVudCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUgPSBJTlQ7XHJcblx0XHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XHJcblx0XHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyB0aHJvdyBvbiBkb3VibGUgY29tbWFzIChlLmcuIFwiMSwgLCAyXCIpXHJcblx0XHRcdFx0XHRpZiAoIFJFLkNPTU1BLnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggc2VlbkNvbW1hICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHNlZW5Db21tYSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHBhcnNlIGludGVnZXIgcGFydFxyXG5cdFx0XHRcdGlmICggc3RhdGUgPT09IElOVCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdG51bWJlciArPSBjdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBSRS5QT0lOVC50ZXN0KCBjdXJyZW50ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gY3VycmVudDtcclxuXHRcdFx0XHRcdFx0c3RhdGUgPSBGTE9BVDtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggUkUuRVhQLnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlID0gRVhQO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhyb3cgb24gZG91YmxlIHNpZ25zIChcIi0rMVwiKSwgYnV0IG5vdCBvbiBzaWduIGFzIHNlcGFyYXRvciAoXCItMS0yXCIpXHJcblx0XHRcdFx0XHRpZiAoIFJFLlNJR04udGVzdCggY3VycmVudCApXHJcblx0XHRcdFx0XHRcdFx0JiYgbnVtYmVyLmxlbmd0aCA9PT0gMVxyXG5cdFx0XHRcdFx0XHRcdCYmIFJFLlNJR04udGVzdCggbnVtYmVyWyAwIF0gKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBwYXJzZSBkZWNpbWFsIHBhcnRcclxuXHRcdFx0XHRpZiAoIHN0YXRlID09PSBGTE9BVCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdG51bWJlciArPSBjdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBSRS5FWFAudGVzdCggY3VycmVudCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUgPSBFWFA7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyB0aHJvdyBvbiBkb3VibGUgZGVjaW1hbCBwb2ludHMgKGUuZy4gXCIxLi4yXCIpXHJcblx0XHRcdFx0XHRpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSAmJiBudW1iZXJbIG51bWJlci5sZW5ndGggLSAxIF0gPT09ICcuJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBwYXJzZSBleHBvbmVudCBwYXJ0XHJcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gRVhQICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggUkUuRElHSVQudGVzdCggY3VycmVudCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZXhwb25lbnQgKz0gY3VycmVudDtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGV4cG9uZW50ID09PSAnJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZXhwb25lbnQgKz0gY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggZXhwb25lbnQubGVuZ3RoID09PSAxICYmIFJFLlNJR04udGVzdCggZXhwb25lbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHQvLyBlbmQgb2YgbnVtYmVyXHJcblx0XHRcdFx0aWYgKCBSRS5XSElURVNQQUNFLnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcclxuXHRcdFx0XHRcdHN0YXRlID0gU0VQO1xyXG5cdFx0XHRcdFx0c2VlbkNvbW1hID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLkNPTU1BLnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcclxuXHRcdFx0XHRcdHN0YXRlID0gU0VQO1xyXG5cdFx0XHRcdFx0c2VlbkNvbW1hID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmV3TnVtYmVyKCk7XHJcblx0XHRcdFx0XHRzdGF0ZSA9IElOVDtcclxuXHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcclxuXHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XHJcblx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhZGQgdGhlIGxhc3QgbnVtYmVyIGZvdW5kIChpZiBhbnkpXHJcblx0XHRcdG5ld051bWJlcigpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVW5pdHNcclxuXHJcblx0XHRjb25zdCB1bml0cyA9IFsgJ21tJywgJ2NtJywgJ2luJywgJ3B0JywgJ3BjJywgJ3B4JyBdO1xyXG5cclxuXHRcdC8vIENvbnZlcnNpb246IFsgZnJvbVVuaXQgXVsgdG9Vbml0IF0gKC0xIG1lYW5zIGRwaSBkZXBlbmRlbnQpXHJcblx0XHRjb25zdCB1bml0Q29udmVyc2lvbiA9IHtcclxuXHJcblx0XHRcdCdtbSc6IHtcclxuXHRcdFx0XHQnbW0nOiAxLFxyXG5cdFx0XHRcdCdjbSc6IDAuMSxcclxuXHRcdFx0XHQnaW4nOiAxIC8gMjUuNCxcclxuXHRcdFx0XHQncHQnOiA3MiAvIDI1LjQsXHJcblx0XHRcdFx0J3BjJzogNiAvIDI1LjQsXHJcblx0XHRcdFx0J3B4JzogLSAxXHJcblx0XHRcdH0sXHJcblx0XHRcdCdjbSc6IHtcclxuXHRcdFx0XHQnbW0nOiAxMCxcclxuXHRcdFx0XHQnY20nOiAxLFxyXG5cdFx0XHRcdCdpbic6IDEgLyAyLjU0LFxyXG5cdFx0XHRcdCdwdCc6IDcyIC8gMi41NCxcclxuXHRcdFx0XHQncGMnOiA2IC8gMi41NCxcclxuXHRcdFx0XHQncHgnOiAtIDFcclxuXHRcdFx0fSxcclxuXHRcdFx0J2luJzoge1xyXG5cdFx0XHRcdCdtbSc6IDI1LjQsXHJcblx0XHRcdFx0J2NtJzogMi41NCxcclxuXHRcdFx0XHQnaW4nOiAxLFxyXG5cdFx0XHRcdCdwdCc6IDcyLFxyXG5cdFx0XHRcdCdwYyc6IDYsXHJcblx0XHRcdFx0J3B4JzogLSAxXHJcblx0XHRcdH0sXHJcblx0XHRcdCdwdCc6IHtcclxuXHRcdFx0XHQnbW0nOiAyNS40IC8gNzIsXHJcblx0XHRcdFx0J2NtJzogMi41NCAvIDcyLFxyXG5cdFx0XHRcdCdpbic6IDEgLyA3MixcclxuXHRcdFx0XHQncHQnOiAxLFxyXG5cdFx0XHRcdCdwYyc6IDYgLyA3MixcclxuXHRcdFx0XHQncHgnOiAtIDFcclxuXHRcdFx0fSxcclxuXHRcdFx0J3BjJzoge1xyXG5cdFx0XHRcdCdtbSc6IDI1LjQgLyA2LFxyXG5cdFx0XHRcdCdjbSc6IDIuNTQgLyA2LFxyXG5cdFx0XHRcdCdpbic6IDEgLyA2LFxyXG5cdFx0XHRcdCdwdCc6IDcyIC8gNixcclxuXHRcdFx0XHQncGMnOiAxLFxyXG5cdFx0XHRcdCdweCc6IC0gMVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQncHgnOiB7XHJcblx0XHRcdFx0J3B4JzogMVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0V2l0aFVuaXRzKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0XHRsZXQgdGhlVW5pdCA9ICdweCc7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnIHx8IHN0cmluZyBpbnN0YW5jZW9mIFN0cmluZyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gdW5pdHMubGVuZ3RoOyBpIDwgbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB1ID0gdW5pdHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHN0cmluZy5lbmRzV2l0aCggdSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhlVW5pdCA9IHU7XHJcblx0XHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoIDAsIHN0cmluZy5sZW5ndGggLSB1Lmxlbmd0aCApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBzY2FsZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICggdGhlVW5pdCA9PT0gJ3B4JyAmJiBzY29wZS5kZWZhdWx0VW5pdCAhPT0gJ3B4JyApIHtcclxuXHJcblx0XHRcdFx0Ly8gQ29udmVyc2lvbiBzY2FsZSBmcm9tICBwaXhlbHMgdG8gaW5jaGVzLCB0aGVuIHRvIGRlZmF1bHQgdW5pdHNcclxuXHJcblx0XHRcdFx0c2NhbGUgPSB1bml0Q29udmVyc2lvblsgJ2luJyBdWyBzY29wZS5kZWZhdWx0VW5pdCBdIC8gc2NvcGUuZGVmYXVsdERQSTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNjYWxlID0gdW5pdENvbnZlcnNpb25bIHRoZVVuaXQgXVsgc2NvcGUuZGVmYXVsdFVuaXQgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBzY2FsZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ29udmVyc2lvbiBzY2FsZSB0byBwaXhlbHNcclxuXHJcblx0XHRcdFx0XHRzY2FsZSA9IHVuaXRDb252ZXJzaW9uWyB0aGVVbml0IF1bICdpbicgXSAqIHNjb3BlLmRlZmF1bHREUEk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzY2FsZSAqIHBhcnNlRmxvYXQoIHN0cmluZyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmFuc2Zvcm1zXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0Tm9kZVRyYW5zZm9ybSggbm9kZSApIHtcclxuXHJcblx0XHRcdGlmICggISAoIG5vZGUuaGFzQXR0cmlidXRlKCAndHJhbnNmb3JtJyApIHx8ICggbm9kZS5ub2RlTmFtZSA9PT0gJ3VzZScgJiYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3gnICkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoICd5JyApICkgKSApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHBhcnNlTm9kZVRyYW5zZm9ybSggbm9kZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0cmFuc2Zvcm1TdGFjay5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHR0cmFuc2Zvcm0ucHJlbXVsdGlwbHkoIHRyYW5zZm9ybVN0YWNrWyB0cmFuc2Zvcm1TdGFjay5sZW5ndGggLSAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uY29weSggdHJhbnNmb3JtICk7XHJcblx0XHRcdHRyYW5zZm9ybVN0YWNrLnB1c2goIHRyYW5zZm9ybSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlVHJhbnNmb3JtKCBub2RlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcclxuXHRcdFx0Y29uc3QgY3VycmVudFRyYW5zZm9ybSA9IHRlbXBUcmFuc2Zvcm0wO1xyXG5cclxuXHRcdFx0aWYgKCBub2RlLm5vZGVOYW1lID09PSAndXNlJyAmJiAoIG5vZGUuaGFzQXR0cmlidXRlKCAneCcgKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSggJ3knICkgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gnICkgKTtcclxuXHRcdFx0XHRjb25zdCB0eSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneScgKSApO1xyXG5cclxuXHRcdFx0XHR0cmFuc2Zvcm0udHJhbnNsYXRlKCB0eCwgdHkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICd0cmFuc2Zvcm0nICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRyYW5zZm9ybXNUZXh0cyA9IG5vZGUuZ2V0QXR0cmlidXRlKCAndHJhbnNmb3JtJyApLnNwbGl0KCAnKScgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IHRJbmRleCA9IHRyYW5zZm9ybXNUZXh0cy5sZW5ndGggLSAxOyB0SW5kZXggPj0gMDsgdEluZGV4IC0tICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHRyYW5zZm9ybVRleHQgPSB0cmFuc2Zvcm1zVGV4dHNbIHRJbmRleCBdLnRyaW0oKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRyYW5zZm9ybVRleHQgPT09ICcnICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgb3BlblBhclBvcyA9IHRyYW5zZm9ybVRleHQuaW5kZXhPZiggJygnICk7XHJcblx0XHRcdFx0XHRjb25zdCBjbG9zZVBhclBvcyA9IHRyYW5zZm9ybVRleHQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggb3BlblBhclBvcyA+IDAgJiYgb3BlblBhclBvcyA8IGNsb3NlUGFyUG9zICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtVHlwZSA9IHRyYW5zZm9ybVRleHQuc2xpY2UoIDAsIG9wZW5QYXJQb3MgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGFycmF5ID0gcGFyc2VGbG9hdHMoIHRyYW5zZm9ybVRleHQuc2xpY2UoIG9wZW5QYXJQb3MgKyAxICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcclxuXHJcblx0XHRcdFx0XHRcdHN3aXRjaCAoIHRyYW5zZm9ybVR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHR4ID0gYXJyYXlbIDAgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IHR5ID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5ID0gYXJyYXlbIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0udHJhbnNsYXRlKCB0eCwgdHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBhbmdsZSA9IDA7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBjeCA9IDA7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBjeSA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBbmdsZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRhbmdsZSA9IGFycmF5WyAwIF0gKiBNYXRoLlBJIC8gMTgwO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2VudGVyIHgsIHlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjeCA9IGFycmF5WyAxIF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3kgPSBhcnJheVsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUm90YXRlIGFyb3VuZCBjZW50ZXIgKGN4LCBjeSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTEubWFrZVRyYW5zbGF0aW9uKCAtIGN4LCAtIGN5ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0yLm1ha2VSb3RhdGlvbiggYW5nbGUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTMubXVsdGlwbHlNYXRyaWNlcyggdGVtcFRyYW5zZm9ybTIsIHRlbXBUcmFuc2Zvcm0xICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0xLm1ha2VUcmFuc2xhdGlvbiggY3gsIGN5ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0ubXVsdGlwbHlNYXRyaWNlcyggdGVtcFRyYW5zZm9ybTEsIHRlbXBUcmFuc2Zvcm0zICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNjYWxlWCA9IGFycmF5WyAwIF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBzY2FsZVkgPSBzY2FsZVg7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzY2FsZVkgPSBhcnJheVsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zY2FsZSggc2NhbGVYLCBzY2FsZVkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3NrZXdYJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2V0KFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDEsIE1hdGgudGFuKCBhcnJheVsgMCBdICogTWF0aC5QSSAvIDE4MCApLCAwLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDEsIDAsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMCwgMVxyXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnc2tld1knOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zZXQoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0MSwgMCwgMCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLnRhbiggYXJyYXlbIDAgXSAqIE1hdGguUEkgLyAxODAgKSwgMSwgMCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQwLCAwLCAxXHJcblx0XHRcdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zZXQoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YXJyYXlbIDAgXSwgYXJyYXlbIDIgXSwgYXJyYXlbIDQgXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhcnJheVsgMSBdLCBhcnJheVsgMyBdLCBhcnJheVsgNSBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDAsIDFcclxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRyYW5zZm9ybS5wcmVtdWx0aXBseSggY3VycmVudFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKCBwYXRoLCBtICkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gdHJhbnNmVmVjMiggdjIgKSB7XHJcblxyXG5cdFx0XHRcdHRlbXBWMy5zZXQoIHYyLngsIHYyLnksIDEgKS5hcHBseU1hdHJpeDMoIG0gKTtcclxuXHJcblx0XHRcdFx0djIuc2V0KCB0ZW1wVjMueCwgdGVtcFYzLnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHRyYW5zZkVsbGlwc2VHZW5lcmljKCBjdXJ2ZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gRm9yIG1hdGggZGVzY3JpcHRpb24gc2VlOlxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNDU0NDE2NFxyXG5cclxuXHRcdFx0XHRjb25zdCBhID0gY3VydmUueFJhZGl1cztcclxuXHRcdFx0XHRjb25zdCBiID0gY3VydmUueVJhZGl1cztcclxuXHJcblx0XHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyggY3VydmUuYVJvdGF0aW9uICk7XHJcblx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbiggY3VydmUuYVJvdGF0aW9uICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHYxID0gbmV3IFZlY3RvcjMoIGEgKiBjb3NUaGV0YSwgYSAqIHNpblRoZXRhLCAwICk7XHJcblx0XHRcdFx0Y29uc3QgdjIgPSBuZXcgVmVjdG9yMyggLSBiICogc2luVGhldGEsIGIgKiBjb3NUaGV0YSwgMCApO1xyXG5cclxuXHRcdFx0XHRjb25zdCBmMSA9IHYxLmFwcGx5TWF0cml4MyggbSApO1xyXG5cdFx0XHRcdGNvbnN0IGYyID0gdjIuYXBwbHlNYXRyaXgzKCBtICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG1GID0gdGVtcFRyYW5zZm9ybTAuc2V0KFxyXG5cdFx0XHRcdFx0ZjEueCwgZjIueCwgMCxcclxuXHRcdFx0XHRcdGYxLnksIGYyLnksIDAsXHJcblx0XHRcdFx0XHQwLCAwLCAxLFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG1GSW52ID0gdGVtcFRyYW5zZm9ybTEuY29weSggbUYgKS5pbnZlcnQoKTtcclxuXHRcdFx0XHRjb25zdCBtRkludlQgPSB0ZW1wVHJhbnNmb3JtMi5jb3B5KCBtRkludiApLnRyYW5zcG9zZSgpO1xyXG5cdFx0XHRcdGNvbnN0IG1RID0gbUZJbnZULm11bHRpcGx5KCBtRkludiApO1xyXG5cdFx0XHRcdGNvbnN0IG1RZSA9IG1RLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0XHRjb25zdCBlZCA9IGVpZ2VuRGVjb21wb3NpdGlvbiggbVFlWyAwIF0sIG1RZVsgMSBdLCBtUWVbIDQgXSApO1xyXG5cdFx0XHRcdGNvbnN0IHJ0MXNxcnQgPSBNYXRoLnNxcnQoIGVkLnJ0MSApO1xyXG5cdFx0XHRcdGNvbnN0IHJ0MnNxcnQgPSBNYXRoLnNxcnQoIGVkLnJ0MiApO1xyXG5cclxuXHRcdFx0XHRjdXJ2ZS54UmFkaXVzID0gMSAvIHJ0MXNxcnQ7XHJcblx0XHRcdFx0Y3VydmUueVJhZGl1cyA9IDEgLyBydDJzcXJ0O1xyXG5cdFx0XHRcdGN1cnZlLmFSb3RhdGlvbiA9IE1hdGguYXRhbjIoIGVkLnNuLCBlZC5jcyApO1xyXG5cclxuXHRcdFx0XHRjb25zdCBpc0Z1bGxFbGxpcHNlID1cclxuXHRcdFx0XHRcdCggY3VydmUuYUVuZEFuZ2xlIC0gY3VydmUuYVN0YXJ0QW5nbGUgKSAlICggMiAqIE1hdGguUEkgKSA8IE51bWJlci5FUFNJTE9OO1xyXG5cclxuXHRcdFx0XHQvLyBEbyBub3QgdG91Y2ggYW5nbGVzIG9mIGEgZnVsbCBlbGxpcHNlIGJlY2F1c2UgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gdGhleVxyXG5cdFx0XHRcdC8vIHdvdWxkIGNvbnZlcmdlIHRvIGEgc2lubGUgdmFsdWUgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgdGhlIHdob2xlIGN1cnZlXHJcblxyXG5cdFx0XHRcdGlmICggISBpc0Z1bGxFbGxpcHNlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG1Ec3FydCA9IHRlbXBUcmFuc2Zvcm0xLnNldChcclxuXHRcdFx0XHRcdFx0cnQxc3FydCwgMCwgMCxcclxuXHRcdFx0XHRcdFx0MCwgcnQyc3FydCwgMCxcclxuXHRcdFx0XHRcdFx0MCwgMCwgMSxcclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgbVJUID0gdGVtcFRyYW5zZm9ybTIuc2V0KFxyXG5cdFx0XHRcdFx0XHRlZC5jcywgZWQuc24sIDAsXHJcblx0XHRcdFx0XHRcdC0gZWQuc24sIGVkLmNzLCAwLFxyXG5cdFx0XHRcdFx0XHQwLCAwLCAxLFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBtRFJGID0gbURzcXJ0Lm11bHRpcGx5KCBtUlQgKS5tdWx0aXBseSggbUYgKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0cmFuc2Zvcm1BbmdsZSA9IHBoaSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB7IHg6IGNvc1IsIHk6IHNpblIgfSA9XHJcblx0XHRcdFx0XHRcdFx0bmV3IFZlY3RvcjMoIE1hdGguY29zKCBwaGkgKSwgTWF0aC5zaW4oIHBoaSApLCAwICkuYXBwbHlNYXRyaXgzKCBtRFJGICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggc2luUiwgY29zUiApO1xyXG5cclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0Y3VydmUuYVN0YXJ0QW5nbGUgPSB0cmFuc2Zvcm1BbmdsZSggY3VydmUuYVN0YXJ0QW5nbGUgKTtcclxuXHRcdFx0XHRcdGN1cnZlLmFFbmRBbmdsZSA9IHRyYW5zZm9ybUFuZ2xlKCBjdXJ2ZS5hRW5kQW5nbGUgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzVHJhbnNmb3JtRmxpcHBlZCggbSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3VydmUuYUNsb2Nrd2lzZSA9ICEgY3VydmUuYUNsb2Nrd2lzZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHRyYW5zZkVsbGlwc2VOb1NrZXcoIGN1cnZlICkge1xyXG5cclxuXHRcdFx0XHQvLyBGYXN0ZXIgc2hvcnRjdXQgaWYgbm8gc2tldyBpcyBhcHBsaWVkXHJcblx0XHRcdFx0Ly8gKGUuZywgYSBldWNsaWRlYW4gdHJhbnNmb3JtIG9mIGEgZ3JvdXAgY29udGFpbmluZyB0aGUgZWxsaXBzZSlcclxuXHJcblx0XHRcdFx0Y29uc3Qgc3ggPSBnZXRUcmFuc2Zvcm1TY2FsZVgoIG0gKTtcclxuXHRcdFx0XHRjb25zdCBzeSA9IGdldFRyYW5zZm9ybVNjYWxlWSggbSApO1xyXG5cclxuXHRcdFx0XHRjdXJ2ZS54UmFkaXVzICo9IHN4O1xyXG5cdFx0XHRcdGN1cnZlLnlSYWRpdXMgKj0gc3k7XHJcblxyXG5cdFx0XHRcdC8vIEV4dHJhY3Qgcm90YXRpb24gYW5nbGUgZnJvbSB0aGUgbWF0cml4IG9mIGZvcm06XHJcblx0XHRcdFx0Ly9cclxuXHRcdFx0XHQvLyAgfCBjb3POuCBzeCAgIC1zaW7OuCBzeSB8XHJcblx0XHRcdFx0Ly8gIHwgc2luzrggc3ggICAgY29zzrggc3kgfFxyXG5cdFx0XHRcdC8vXHJcblx0XHRcdFx0Ly8gUmVtZW1iZXJpbmcgdGhhdCB0YW7OuCA9IHNpbs64IC8gY29zzrg7IGFuZCB0aGF0XHJcblx0XHRcdFx0Ly8gYHN4YCwgYHN5YCwgb3IgYm90aCBtaWdodCBiZSB6ZXJvLlxyXG5cdFx0XHRcdGNvbnN0IHRoZXRhID1cclxuXHRcdFx0XHRcdHN4ID4gTnVtYmVyLkVQU0lMT05cclxuXHRcdFx0XHRcdFx0PyBNYXRoLmF0YW4yKCBtLmVsZW1lbnRzWyAxIF0sIG0uZWxlbWVudHNbIDAgXSApXHJcblx0XHRcdFx0XHRcdDogTWF0aC5hdGFuMiggLSBtLmVsZW1lbnRzWyAzIF0sIG0uZWxlbWVudHNbIDQgXSApO1xyXG5cclxuXHRcdFx0XHRjdXJ2ZS5hUm90YXRpb24gKz0gdGhldGE7XHJcblxyXG5cdFx0XHRcdGlmICggaXNUcmFuc2Zvcm1GbGlwcGVkKCBtICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VydmUuYVN0YXJ0QW5nbGUgKj0gLSAxO1xyXG5cdFx0XHRcdFx0Y3VydmUuYUVuZEFuZ2xlICo9IC0gMTtcclxuXHRcdFx0XHRcdGN1cnZlLmFDbG9ja3dpc2UgPSAhIGN1cnZlLmFDbG9ja3dpc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHN1YlBhdGhzID0gcGF0aC5zdWJQYXRocztcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IG47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN1YlBhdGggPSBzdWJQYXRoc1sgaSBdO1xyXG5cdFx0XHRcdGNvbnN0IGN1cnZlcyA9IHN1YlBhdGguY3VydmVzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBjdXJ2ZXMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGN1cnZlID0gY3VydmVzWyBqIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXJ2ZS5pc0xpbmVDdXJ2ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYxICk7XHJcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYyICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VydmUuaXNDdWJpY0JlemllckN1cnZlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjAgKTtcclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjEgKTtcclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjMgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJ2ZS5pc1F1YWRyYXRpY0JlemllckN1cnZlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjAgKTtcclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjEgKTtcclxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFRyYW5zZm9ybSBlbGxpcHNlIGNlbnRlciBwb2ludFxyXG5cclxuXHRcdFx0XHRcdFx0dGVtcFYyLnNldCggY3VydmUuYVgsIGN1cnZlLmFZICk7XHJcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIHRlbXBWMiApO1xyXG5cdFx0XHRcdFx0XHRjdXJ2ZS5hWCA9IHRlbXBWMi54O1xyXG5cdFx0XHRcdFx0XHRjdXJ2ZS5hWSA9IHRlbXBWMi55O1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gVHJhbnNmb3JtIGVsbGlwc2Ugc2hhcGUgcGFyYW1ldGVyc1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpc1RyYW5zZm9ybVNrZXdlZCggbSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0cmFuc2ZFbGxpcHNlR2VuZXJpYyggY3VydmUgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRyYW5zZkVsbGlwc2VOb1NrZXcoIGN1cnZlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGlzVHJhbnNmb3JtRmxpcHBlZCggbSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cztcclxuXHRcdFx0cmV0dXJuIHRlWyAwIF0gKiB0ZVsgNCBdIC0gdGVbIDEgXSAqIHRlWyAzIF0gPCAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1RyYW5zZm9ybVNrZXdlZCggbSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cztcclxuXHRcdFx0Y29uc3QgYmFzaXNEb3QgPSB0ZVsgMCBdICogdGVbIDMgXSArIHRlWyAxIF0gKiB0ZVsgNCBdO1xyXG5cclxuXHRcdFx0Ly8gU2hvcnRjdXQgZm9yIHRyaXZpYWwgcm90YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnNcclxuXHRcdFx0aWYgKCBiYXNpc0RvdCA9PT0gMCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdGNvbnN0IHN4ID0gZ2V0VHJhbnNmb3JtU2NhbGVYKCBtICk7XHJcblx0XHRcdGNvbnN0IHN5ID0gZ2V0VHJhbnNmb3JtU2NhbGVZKCBtICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIGJhc2lzRG90IC8gKCBzeCAqIHN5ICkgKSA+IE51bWJlci5FUFNJTE9OO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TY2FsZVgoIG0gKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHM7XHJcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVZKCBtICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0ZVsgMyBdICogdGVbIDMgXSArIHRlWyA0IF0gKiB0ZVsgNCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENhbGN1bGF0ZXMgdGhlIGVpZ2Vuc3lzdGVtIG9mIGEgcmVhbCBzeW1tZXRyaWMgMngyIG1hdHJpeFxyXG5cdFx0Ly8gICAgWyBBICBCIF1cclxuXHRcdC8vICAgIFsgQiAgQyBdXHJcblx0XHQvLyBpbiB0aGUgZm9ybVxyXG5cdFx0Ly8gICAgWyBBICBCIF0gID0gIFsgY3MgIC1zbiBdIFsgcnQxICAgMCAgXSBbICBjcyAgc24gXVxyXG5cdFx0Ly8gICAgWyBCICBDIF0gICAgIFsgc24gICBjcyBdIFsgIDAgICBydDIgXSBbIC1zbiAgY3MgXVxyXG5cdFx0Ly8gd2hlcmUgcnQxID49IHJ0Mi5cclxuXHRcdC8vXHJcblx0XHQvLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vd3d3Lm1waS1oZC5tcGcuZGUvcGVyc29uYWxob21lcy9nbG9iZXMvM3gzL2luZGV4Lmh0bWxcclxuXHRcdC8vIC0+IEFsZ29yaXRobXMgZm9yIHJlYWwgc3ltbWV0cmljIG1hdHJpY2VzIC0+IEFuYWx5dGljYWwgKDJ4MiBzeW1tZXRyaWMpXHJcblx0XHRmdW5jdGlvbiBlaWdlbkRlY29tcG9zaXRpb24oIEEsIEIsIEMgKSB7XHJcblxyXG5cdFx0XHRsZXQgcnQxLCBydDIsIGNzLCBzbiwgdDtcclxuXHRcdFx0Y29uc3Qgc20gPSBBICsgQztcclxuXHRcdFx0Y29uc3QgZGYgPSBBIC0gQztcclxuXHRcdFx0Y29uc3QgcnQgPSBNYXRoLnNxcnQoIGRmICogZGYgKyA0ICogQiAqIEIgKTtcclxuXHJcblx0XHRcdGlmICggc20gPiAwICkge1xyXG5cclxuXHRcdFx0XHRydDEgPSAwLjUgKiAoIHNtICsgcnQgKTtcclxuXHRcdFx0XHR0ID0gMSAvIHJ0MTtcclxuXHRcdFx0XHRydDIgPSBBICogdCAqIEMgLSBCICogdCAqIEI7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBzbSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJ0MiA9IDAuNSAqICggc20gLSBydCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gVGhpcyBjYXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgc2VwYXJhdGVseSB0byBhdm9pZCBkaXYgYnkgMFxyXG5cclxuXHRcdFx0XHRydDEgPSAwLjUgKiBydDtcclxuXHRcdFx0XHRydDIgPSAtIDAuNSAqIHJ0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGVpZ2VudmVjdG9yc1xyXG5cclxuXHRcdFx0aWYgKCBkZiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNzID0gZGYgKyBydDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNzID0gZGYgLSBydDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGNzICkgPiAyICogTWF0aC5hYnMoIEIgKSApIHtcclxuXHJcblx0XHRcdFx0dCA9IC0gMiAqIEIgLyBjcztcclxuXHRcdFx0XHRzbiA9IDEgLyBNYXRoLnNxcnQoIDEgKyB0ICogdCApO1xyXG5cdFx0XHRcdGNzID0gdCAqIHNuO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIEIgKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Y3MgPSAxO1xyXG5cdFx0XHRcdHNuID0gMDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHQgPSAtIDAuNSAqIGNzIC8gQjtcclxuXHRcdFx0XHRjcyA9IDEgLyBNYXRoLnNxcnQoIDEgKyB0ICogdCApO1xyXG5cdFx0XHRcdHNuID0gdCAqIGNzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkZiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBjcztcclxuXHRcdFx0XHRjcyA9IC0gc247XHJcblx0XHRcdFx0c24gPSB0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHsgcnQxLCBydDIsIGNzLCBzbiB9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IHBhdGhzID0gW107XHJcblx0XHRjb25zdCBzdHlsZXNoZWV0cyA9IHt9O1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zZm9ybVN0YWNrID0gW107XHJcblxyXG5cdFx0Y29uc3QgdGVtcFRyYW5zZm9ybTAgPSBuZXcgTWF0cml4MygpO1xyXG5cdFx0Y29uc3QgdGVtcFRyYW5zZm9ybTEgPSBuZXcgTWF0cml4MygpO1xyXG5cdFx0Y29uc3QgdGVtcFRyYW5zZm9ybTIgPSBuZXcgTWF0cml4MygpO1xyXG5cdFx0Y29uc3QgdGVtcFRyYW5zZm9ybTMgPSBuZXcgTWF0cml4MygpO1xyXG5cdFx0Y29uc3QgdGVtcFYyID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdGNvbnN0IHRlbXBWMyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Y29uc3QgY3VycmVudFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgzKCk7XHJcblxyXG5cdFx0Y29uc3QgeG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgJ2ltYWdlL3N2Zyt4bWwnICk7IC8vIGFwcGxpY2F0aW9uL3htbFxyXG5cclxuXHRcdHBhcnNlTm9kZSggeG1sLmRvY3VtZW50RWxlbWVudCwge1xyXG5cdFx0XHRmaWxsOiAnIzAwMCcsXHJcblx0XHRcdGZpbGxPcGFjaXR5OiAxLFxyXG5cdFx0XHRzdHJva2VPcGFjaXR5OiAxLFxyXG5cdFx0XHRzdHJva2VXaWR0aDogMSxcclxuXHRcdFx0c3Ryb2tlTGluZUpvaW46ICdtaXRlcicsXHJcblx0XHRcdHN0cm9rZUxpbmVDYXA6ICdidXR0JyxcclxuXHRcdFx0c3Ryb2tlTWl0ZXJMaW1pdDogNFxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSB7IHBhdGhzOiBwYXRocywgeG1sOiB4bWwuZG9jdW1lbnRFbGVtZW50IH07XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coIHBhdGhzICk7XHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgY3JlYXRlU2hhcGVzKCBzaGFwZVBhdGggKSB7XHJcblxyXG5cdFx0Ly8gUGFyYW0gc2hhcGVQYXRoOiBhIHNoYXBlcGF0aCBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2UgZnVuY3Rpb24gb2YgdGhpcyBjbGFzc1xyXG5cdFx0Ly8gUmV0dXJucyBTaGFwZSBvYmplY3RcclxuXHJcblx0XHRjb25zdCBCSUdOVU1CRVIgPSA5OTk5OTk5OTk7XHJcblxyXG5cdFx0Y29uc3QgSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlID0ge1xyXG5cdFx0XHRPUklHSU46IDAsXHJcblx0XHRcdERFU1RJTkFUSU9OOiAxLFxyXG5cdFx0XHRCRVRXRUVOOiAyLFxyXG5cdFx0XHRMRUZUOiAzLFxyXG5cdFx0XHRSSUdIVDogNCxcclxuXHRcdFx0QkVISU5EOiA1LFxyXG5cdFx0XHRCRVlPTkQ6IDZcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgY2xhc3NpZnlSZXN1bHQgPSB7XHJcblx0XHRcdGxvYzogSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTixcclxuXHRcdFx0dDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBmaW5kRWRnZUludGVyc2VjdGlvbiggYTAsIGExLCBiMCwgYjEgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB4MSA9IGEwLng7XHJcblx0XHRcdGNvbnN0IHgyID0gYTEueDtcclxuXHRcdFx0Y29uc3QgeDMgPSBiMC54O1xyXG5cdFx0XHRjb25zdCB4NCA9IGIxLng7XHJcblx0XHRcdGNvbnN0IHkxID0gYTAueTtcclxuXHRcdFx0Y29uc3QgeTIgPSBhMS55O1xyXG5cdFx0XHRjb25zdCB5MyA9IGIwLnk7XHJcblx0XHRcdGNvbnN0IHk0ID0gYjEueTtcclxuXHRcdFx0Y29uc3Qgbm9tMSA9ICggeDQgLSB4MyApICogKCB5MSAtIHkzICkgLSAoIHk0IC0geTMgKSAqICggeDEgLSB4MyApO1xyXG5cdFx0XHRjb25zdCBub20yID0gKCB4MiAtIHgxICkgKiAoIHkxIC0geTMgKSAtICggeTIgLSB5MSApICogKCB4MSAtIHgzICk7XHJcblx0XHRcdGNvbnN0IGRlbm9tID0gKCB5NCAtIHkzICkgKiAoIHgyIC0geDEgKSAtICggeDQgLSB4MyApICogKCB5MiAtIHkxICk7XHJcblx0XHRcdGNvbnN0IHQxID0gbm9tMSAvIGRlbm9tO1xyXG5cdFx0XHRjb25zdCB0MiA9IG5vbTIgLyBkZW5vbTtcclxuXHJcblx0XHRcdGlmICggKCAoIGRlbm9tID09PSAwICkgJiYgKCBub20xICE9PSAwICkgKSB8fCAoIHQxIDw9IDAgKSB8fCAoIHQxID49IDEgKSB8fCAoIHQyIDwgMCApIHx8ICggdDIgPiAxICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vMS4gbGluZXMgYXJlIHBhcmFsbGVsIG9yIGVkZ2VzIGRvbid0IGludGVyc2VjdFxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoICggbm9tMSA9PT0gMCApICYmICggZGVub20gPT09IDAgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8yLiBsaW5lcyBhcmUgY29saW5lYXJcclxuXHJcblx0XHRcdFx0Ly9jaGVjayBpZiBlbmRwb2ludHMgb2YgZWRnZTIgKGIwLWIxKSBsaWVzIG9uIGVkZ2UxIChhMC1hMSlcclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNsYXNzaWZ5UG9pbnQoIGkgPT09IDAgPyBiMCA6IGIxLCBhMCwgYTEgKTtcclxuXHRcdFx0XHRcdC8vZmluZCBwb3NpdGlvbiBvZiB0aGlzIGVuZHBvaW50cyByZWxhdGl2ZWx5IHRvIGVkZ2UxXHJcblx0XHRcdFx0XHRpZiAoIGNsYXNzaWZ5UmVzdWx0LmxvYyA9PSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSAoIGkgPT09IDAgPyBiMCA6IGIxICk7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7IHg6IHBvaW50LngsIHk6IHBvaW50LnksIHQ6IGNsYXNzaWZ5UmVzdWx0LnQgfTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFVFdFRU4gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB4ID0gKyAoICggeDEgKyBjbGFzc2lmeVJlc3VsdC50ICogKCB4MiAtIHgxICkgKS50b1ByZWNpc2lvbiggMTAgKSApO1xyXG5cdFx0XHRcdFx0XHRjb25zdCB5ID0gKyAoICggeTEgKyBjbGFzc2lmeVJlc3VsdC50ICogKCB5MiAtIHkxICkgKS50b1ByZWNpc2lvbiggMTAgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4geyB4OiB4LCB5OiB5LCB0OiBjbGFzc2lmeVJlc3VsdC50LCB9O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vMy4gZWRnZXMgaW50ZXJzZWN0XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDI7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2xhc3NpZnlQb2ludCggaSA9PT0gMCA/IGIwIDogYjEsIGEwLCBhMSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY2xhc3NpZnlSZXN1bHQubG9jID09IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5PUklHSU4gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBwb2ludCA9ICggaSA9PT0gMCA/IGIwIDogYjEgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSwgdDogY2xhc3NpZnlSZXN1bHQudCB9O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCB4ID0gKyAoICggeDEgKyB0MSAqICggeDIgLSB4MSApICkudG9QcmVjaXNpb24oIDEwICkgKTtcclxuXHRcdFx0XHRjb25zdCB5ID0gKyAoICggeTEgKyB0MSAqICggeTIgLSB5MSApICkudG9QcmVjaXNpb24oIDEwICkgKTtcclxuXHRcdFx0XHRyZXR1cm4geyB4OiB4LCB5OiB5LCB0OiB0MSB9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjbGFzc2lmeVBvaW50KCBwLCBlZGdlU3RhcnQsIGVkZ2VFbmQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBheCA9IGVkZ2VFbmQueCAtIGVkZ2VTdGFydC54O1xyXG5cdFx0XHRjb25zdCBheSA9IGVkZ2VFbmQueSAtIGVkZ2VTdGFydC55O1xyXG5cdFx0XHRjb25zdCBieCA9IHAueCAtIGVkZ2VTdGFydC54O1xyXG5cdFx0XHRjb25zdCBieSA9IHAueSAtIGVkZ2VTdGFydC55O1xyXG5cdFx0XHRjb25zdCBzYSA9IGF4ICogYnkgLSBieCAqIGF5O1xyXG5cclxuXHRcdFx0aWYgKCAoIHAueCA9PT0gZWRnZVN0YXJ0LnggKSAmJiAoIHAueSA9PT0gZWRnZVN0YXJ0LnkgKSApIHtcclxuXHJcblx0XHRcdFx0Y2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTjtcclxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC50ID0gMDtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICggcC54ID09PSBlZGdlRW5kLnggKSAmJiAoIHAueSA9PT0gZWRnZUVuZC55ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5ERVNUSU5BVElPTjtcclxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC50ID0gMTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHNhIDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0Y2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkxFRlQ7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzYSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuUklHSFQ7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggKCAoIGF4ICogYnggKSA8IDAgKSB8fCAoICggYXkgKiBieSApIDwgMCApICkge1xyXG5cclxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVISU5EO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggKCBNYXRoLnNxcnQoIGF4ICogYXggKyBheSAqIGF5ICkgKSA8ICggTWF0aC5zcXJ0KCBieCAqIGJ4ICsgYnkgKiBieSApICkgKSB7XHJcblxyXG5cdFx0XHRcdGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5CRVlPTkQ7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHQ7XHJcblxyXG5cdFx0XHRpZiAoIGF4ICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHR0ID0gYnggLyBheDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHQgPSBieSAvIGF5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFVFdFRU47XHJcblx0XHRcdGNsYXNzaWZ5UmVzdWx0LnQgPSB0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKCBwYXRoMSwgcGF0aDIgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbnRlcnNlY3Rpb25zUmF3ID0gW107XHJcblx0XHRcdGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpbmRleCA9IDE7IGluZGV4IDwgcGF0aDEubGVuZ3RoOyBpbmRleCArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGF0aDFFZGdlU3RhcnQgPSBwYXRoMVsgaW5kZXggLSAxIF07XHJcblx0XHRcdFx0Y29uc3QgcGF0aDFFZGdlRW5kID0gcGF0aDFbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpbmRleDIgPSAxOyBpbmRleDIgPCBwYXRoMi5sZW5ndGg7IGluZGV4MiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBwYXRoMkVkZ2VTdGFydCA9IHBhdGgyWyBpbmRleDIgLSAxIF07XHJcblx0XHRcdFx0XHRjb25zdCBwYXRoMkVkZ2VFbmQgPSBwYXRoMlsgaW5kZXgyIF07XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0aW9uID0gZmluZEVkZ2VJbnRlcnNlY3Rpb24oIHBhdGgxRWRnZVN0YXJ0LCBwYXRoMUVkZ2VFbmQsIHBhdGgyRWRnZVN0YXJ0LCBwYXRoMkVkZ2VFbmQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiAhPT0gbnVsbCAmJiBpbnRlcnNlY3Rpb25zUmF3LmZpbmQoIGkgPT4gaS50IDw9IGludGVyc2VjdGlvbi50ICsgTnVtYmVyLkVQU0lMT04gJiYgaS50ID49IGludGVyc2VjdGlvbi50IC0gTnVtYmVyLkVQU0lMT04gKSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uc1Jhdy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9ucy5wdXNoKCBuZXcgVmVjdG9yMiggaW50ZXJzZWN0aW9uLngsIGludGVyc2VjdGlvbi55ICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnNlY3Rpb25zO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRTY2FubGluZUludGVyc2VjdGlvbnMoIHNjYW5saW5lLCBib3VuZGluZ0JveCwgcGF0aHMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRib3VuZGluZ0JveC5nZXRDZW50ZXIoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0Y29uc3QgYWxsSW50ZXJzZWN0aW9ucyA9IFtdO1xyXG5cclxuXHRcdFx0cGF0aHMuZm9yRWFjaCggcGF0aCA9PiB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveCBpcyBpbiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBwYXRocy5cclxuXHRcdFx0XHQvLyB0aGlzIGlzIGEgcHJ1bmluZyBtZXRob2QgdG8gbGltaXQgdGhlIHNlYXJjaCBvZiBpbnRlcnNlY3Rpb25zIGluIHBhdGhzIHRoYXQgY2FuJ3QgZW52ZWxvcCBvZiB0aGUgY3VycmVudCBwYXRoLlxyXG5cdFx0XHRcdC8vIGlmIGEgcGF0aCBlbnZlbG9wcyBhbm90aGVyIHBhdGguIFRoZSBjZW50ZXIgb2YgdGhhdCBvdGVyIHBhdGgsIGhhcyB0byBiZSBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZW52ZWxvcGluZyBwYXRoLlxyXG5cdFx0XHRcdGlmICggcGF0aC5ib3VuZGluZ0JveC5jb250YWluc1BvaW50KCBjZW50ZXIgKSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3Rpb25zID0gZ2V0SW50ZXJzZWN0aW9ucyggc2NhbmxpbmUsIHBhdGgucG9pbnRzICk7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9ucy5mb3JFYWNoKCBwID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdGFsbEludGVyc2VjdGlvbnMucHVzaCggeyBpZGVudGlmaWVyOiBwYXRoLmlkZW50aWZpZXIsIGlzQ1c6IHBhdGguaXNDVywgcG9pbnQ6IHAgfSApO1xyXG5cclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0YWxsSW50ZXJzZWN0aW9ucy5zb3J0KCAoIGkxLCBpMiApID0+IHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGkxLnBvaW50LnggLSBpMi5wb2ludC54O1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGFsbEludGVyc2VjdGlvbnM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGlzSG9sZVRvKCBzaW1wbGVQYXRoLCBhbGxQYXRocywgc2NhbmxpbmVNaW5YLCBzY2FubGluZU1heFgsIF9maWxsUnVsZSApIHtcclxuXHJcblx0XHRcdGlmICggX2ZpbGxSdWxlID09PSBudWxsIHx8IF9maWxsUnVsZSA9PT0gdW5kZWZpbmVkIHx8IF9maWxsUnVsZSA9PT0gJycgKSB7XHJcblxyXG5cdFx0XHRcdF9maWxsUnVsZSA9ICdub256ZXJvJztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGNlbnRlckJvdW5kaW5nQm94ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdFx0c2ltcGxlUGF0aC5ib3VuZGluZ0JveC5nZXRDZW50ZXIoIGNlbnRlckJvdW5kaW5nQm94ICk7XHJcblxyXG5cdFx0XHRjb25zdCBzY2FubGluZSA9IFsgbmV3IFZlY3RvcjIoIHNjYW5saW5lTWluWCwgY2VudGVyQm91bmRpbmdCb3gueSApLCBuZXcgVmVjdG9yMiggc2NhbmxpbmVNYXhYLCBjZW50ZXJCb3VuZGluZ0JveC55ICkgXTtcclxuXHJcblx0XHRcdGNvbnN0IHNjYW5saW5lSW50ZXJzZWN0aW9ucyA9IGdldFNjYW5saW5lSW50ZXJzZWN0aW9ucyggc2NhbmxpbmUsIHNpbXBsZVBhdGguYm91bmRpbmdCb3gsIGFsbFBhdGhzICk7XHJcblxyXG5cdFx0XHRzY2FubGluZUludGVyc2VjdGlvbnMuc29ydCggKCBpMSwgaTIgKSA9PiB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpMS5wb2ludC54IC0gaTIucG9pbnQueDtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdGNvbnN0IGJhc2VJbnRlcnNlY3Rpb25zID0gW107XHJcblx0XHRcdGNvbnN0IG90aGVySW50ZXJzZWN0aW9ucyA9IFtdO1xyXG5cclxuXHRcdFx0c2NhbmxpbmVJbnRlcnNlY3Rpb25zLmZvckVhY2goIGkgPT4ge1xyXG5cclxuXHRcdFx0XHRpZiAoIGkuaWRlbnRpZmllciA9PT0gc2ltcGxlUGF0aC5pZGVudGlmaWVyICkge1xyXG5cclxuXHRcdFx0XHRcdGJhc2VJbnRlcnNlY3Rpb25zLnB1c2goIGkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRvdGhlckludGVyc2VjdGlvbnMucHVzaCggaSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRjb25zdCBmaXJzdFhPZlBhdGggPSBiYXNlSW50ZXJzZWN0aW9uc1sgMCBdLnBvaW50Lng7XHJcblxyXG5cdFx0XHQvLyBidWlsZCB1cCB0aGUgcGF0aCBoaWVyYXJjaHlcclxuXHRcdFx0Y29uc3Qgc3RhY2sgPSBbXTtcclxuXHRcdFx0bGV0IGkgPSAwO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBpIDwgb3RoZXJJbnRlcnNlY3Rpb25zLmxlbmd0aCAmJiBvdGhlckludGVyc2VjdGlvbnNbIGkgXS5wb2ludC54IDwgZmlyc3RYT2ZQYXRoICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbIHN0YWNrLmxlbmd0aCAtIDEgXSA9PT0gb3RoZXJJbnRlcnNlY3Rpb25zWyBpIF0uaWRlbnRpZmllciApIHtcclxuXHJcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzdGFjay5wdXNoKCBvdGhlckludGVyc2VjdGlvbnNbIGkgXS5pZGVudGlmaWVyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aSArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0YWNrLnB1c2goIHNpbXBsZVBhdGguaWRlbnRpZmllciApO1xyXG5cclxuXHRcdFx0aWYgKCBfZmlsbFJ1bGUgPT09ICdldmVub2RkJyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaXNIb2xlID0gc3RhY2subGVuZ3RoICUgMiA9PT0gMCA/IHRydWUgOiBmYWxzZTtcclxuXHRcdFx0XHRjb25zdCBpc0hvbGVGb3IgPSBzdGFja1sgc3RhY2subGVuZ3RoIC0gMiBdO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4geyBpZGVudGlmaWVyOiBzaW1wbGVQYXRoLmlkZW50aWZpZXIsIGlzSG9sZTogaXNIb2xlLCBmb3I6IGlzSG9sZUZvciB9O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggX2ZpbGxSdWxlID09PSAnbm9uemVybycgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHBhdGggaXMgYSBob2xlIGJ5IGNvdW50aW5nIHRoZSBhbW91bnQgb2YgcGF0aHMgd2l0aCBhbHRlcm5hdGluZyByb3RhdGlvbnMgaXQgaGFzIHRvIGNyb3NzLlxyXG5cdFx0XHRcdGxldCBpc0hvbGUgPSB0cnVlO1xyXG5cdFx0XHRcdGxldCBpc0hvbGVGb3IgPSBudWxsO1xyXG5cdFx0XHRcdGxldCBsYXN0Q1dWYWx1ZSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpZGVudGlmaWVyID0gc3RhY2tbIGkgXTtcclxuXHRcdFx0XHRcdGlmICggaXNIb2xlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bGFzdENXVmFsdWUgPSBhbGxQYXRoc1sgaWRlbnRpZmllciBdLmlzQ1c7XHJcblx0XHRcdFx0XHRcdGlzSG9sZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRpc0hvbGVGb3IgPSBpZGVudGlmaWVyO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGxhc3RDV1ZhbHVlICE9PSBhbGxQYXRoc1sgaWRlbnRpZmllciBdLmlzQ1cgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRsYXN0Q1dWYWx1ZSA9IGFsbFBhdGhzWyBpZGVudGlmaWVyIF0uaXNDVztcclxuXHRcdFx0XHRcdFx0aXNIb2xlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHsgaWRlbnRpZmllcjogc2ltcGxlUGF0aC5pZGVudGlmaWVyLCBpc0hvbGU6IGlzSG9sZSwgZm9yOiBpc0hvbGVGb3IgfTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ2ZpbGwtcnVsZTogXCInICsgX2ZpbGxSdWxlICsgJ1wiIGlzIGN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBmb3Igc2VsZiBpbnRlcnNlY3RpbmcgcGF0aHNcclxuXHRcdC8vIFRPRE9cclxuXHJcblx0XHQvLyBjaGVjayBpbnRlcnNlY3RpbmcgcGF0aHNcclxuXHRcdC8vIFRPRE9cclxuXHJcblx0XHQvLyBwcmVwYXJlIHBhdGhzIGZvciBob2xlIGRldGVjdGlvblxyXG5cdFx0bGV0IHNjYW5saW5lTWluWCA9IEJJR05VTUJFUjtcclxuXHRcdGxldCBzY2FubGluZU1heFggPSAtIEJJR05VTUJFUjtcclxuXHJcblx0XHRsZXQgc2ltcGxlUGF0aHMgPSBzaGFwZVBhdGguc3ViUGF0aHMubWFwKCBwID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IHAuZ2V0UG9pbnRzKCk7XHJcblx0XHRcdGxldCBtYXhZID0gLSBCSUdOVU1CRVI7XHJcblx0XHRcdGxldCBtaW5ZID0gQklHTlVNQkVSO1xyXG5cdFx0XHRsZXQgbWF4WCA9IC0gQklHTlVNQkVSO1xyXG5cdFx0XHRsZXQgbWluWCA9IEJJR05VTUJFUjtcclxuXHJcblx0ICAgICAgXHQvL3BvaW50cy5mb3JFYWNoKHAgPT4gcC55ICo9IC0xKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwLnkgPiBtYXhZICkge1xyXG5cclxuXHRcdFx0XHRcdG1heFkgPSBwLnk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBwLnkgPCBtaW5ZICkge1xyXG5cclxuXHRcdFx0XHRcdG1pblkgPSBwLnk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBwLnggPiBtYXhYICkge1xyXG5cclxuXHRcdFx0XHRcdG1heFggPSBwLng7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBwLnggPCBtaW5YICkge1xyXG5cclxuXHRcdFx0XHRcdG1pblggPSBwLng7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblx0XHRcdGlmICggc2NhbmxpbmVNYXhYIDw9IG1heFggKSB7XHJcblxyXG5cdFx0XHRcdHNjYW5saW5lTWF4WCA9IG1heFggKyAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzY2FubGluZU1pblggPj0gbWluWCApIHtcclxuXHJcblx0XHRcdFx0c2NhbmxpbmVNaW5YID0gbWluWCAtIDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4geyBjdXJ2ZXM6IHAuY3VydmVzLCBwb2ludHM6IHBvaW50cywgaXNDVzogU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggcG9pbnRzICksIGlkZW50aWZpZXI6IC0gMSwgYm91bmRpbmdCb3g6IG5ldyBCb3gyKCBuZXcgVmVjdG9yMiggbWluWCwgbWluWSApLCBuZXcgVmVjdG9yMiggbWF4WCwgbWF4WSApICkgfTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0c2ltcGxlUGF0aHMgPSBzaW1wbGVQYXRocy5maWx0ZXIoIHNwID0+IHNwLnBvaW50cy5sZW5ndGggPiAxICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGlkZW50aWZpZXIgPSAwOyBpZGVudGlmaWVyIDwgc2ltcGxlUGF0aHMubGVuZ3RoOyBpZGVudGlmaWVyICsrICkge1xyXG5cclxuXHRcdFx0c2ltcGxlUGF0aHNbIGlkZW50aWZpZXIgXS5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgcGF0aCBpcyBzb2xpZCBvciBhIGhvbGVcclxuXHRcdGNvbnN0IGlzQUhvbGUgPSBzaW1wbGVQYXRocy5tYXAoIHAgPT4gaXNIb2xlVG8oIHAsIHNpbXBsZVBhdGhzLCBzY2FubGluZU1pblgsIHNjYW5saW5lTWF4WCwgKCBzaGFwZVBhdGgudXNlckRhdGEgPyBzaGFwZVBhdGgudXNlckRhdGEuc3R5bGUuZmlsbFJ1bGUgOiB1bmRlZmluZWQgKSApICk7XHJcblxyXG5cclxuXHRcdGNvbnN0IHNoYXBlc1RvUmV0dXJuID0gW107XHJcblx0XHRzaW1wbGVQYXRocy5mb3JFYWNoKCBwID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGFtSUFIb2xlID0gaXNBSG9sZVsgcC5pZGVudGlmaWVyIF07XHJcblxyXG5cdFx0XHRpZiAoICEgYW1JQUhvbGUuaXNIb2xlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cdFx0XHRcdHNoYXBlLmN1cnZlcyA9IHAuY3VydmVzO1xyXG5cdFx0XHRcdGNvbnN0IGhvbGVzID0gaXNBSG9sZS5maWx0ZXIoIGggPT4gaC5pc0hvbGUgJiYgaC5mb3IgPT09IHAuaWRlbnRpZmllciApO1xyXG5cdFx0XHRcdGhvbGVzLmZvckVhY2goIGggPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGhvbGUgPSBzaW1wbGVQYXRoc1sgaC5pZGVudGlmaWVyIF07XHJcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gbmV3IFBhdGgoKTtcclxuXHRcdFx0XHRcdHBhdGguY3VydmVzID0gaG9sZS5jdXJ2ZXM7XHJcblx0XHRcdFx0XHRzaGFwZS5ob2xlcy5wdXNoKCBwYXRoICk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHRcdFx0XHRzaGFwZXNUb1JldHVybi5wdXNoKCBzaGFwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzVG9SZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldFN0cm9rZVN0eWxlKCB3aWR0aCwgY29sb3IsIGxpbmVKb2luLCBsaW5lQ2FwLCBtaXRlckxpbWl0ICkge1xyXG5cclxuXHRcdC8vIFBhcmFtIHdpZHRoOiBTdHJva2Ugd2lkdGhcclxuXHRcdC8vIFBhcmFtIGNvbG9yOiBBcyByZXR1cm5lZCBieSBUSFJFRS5Db2xvci5nZXRTdHlsZSgpXHJcblx0XHQvLyBQYXJhbSBsaW5lSm9pbjogT25lIG9mIFwicm91bmRcIiwgXCJiZXZlbFwiLCBcIm1pdGVyXCIgb3IgXCJtaXRlci1saW1pdFwiXHJcblx0XHQvLyBQYXJhbSBsaW5lQ2FwOiBPbmUgb2YgXCJyb3VuZFwiLCBcInNxdWFyZVwiIG9yIFwiYnV0dFwiXHJcblx0XHQvLyBQYXJhbSBtaXRlckxpbWl0OiBNYXhpbXVtIGpvaW4gbGVuZ3RoLCBpbiBtdWx0aXBsZXMgb2YgdGhlIFwid2lkdGhcIiBwYXJhbWV0ZXIgKGpvaW4gaXMgdHJ1bmNhdGVkIGlmIGl0IGV4Y2VlZHMgdGhhdCBkaXN0YW5jZSlcclxuXHRcdC8vIFJldHVybnMgc3R5bGUgb2JqZWN0XHJcblxyXG5cdFx0d2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiAxO1xyXG5cdFx0Y29sb3IgPSBjb2xvciAhPT0gdW5kZWZpbmVkID8gY29sb3IgOiAnIzAwMCc7XHJcblx0XHRsaW5lSm9pbiA9IGxpbmVKb2luICE9PSB1bmRlZmluZWQgPyBsaW5lSm9pbiA6ICdtaXRlcic7XHJcblx0XHRsaW5lQ2FwID0gbGluZUNhcCAhPT0gdW5kZWZpbmVkID8gbGluZUNhcCA6ICdidXR0JztcclxuXHRcdG1pdGVyTGltaXQgPSBtaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgPyBtaXRlckxpbWl0IDogNDtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzdHJva2VDb2xvcjogY29sb3IsXHJcblx0XHRcdHN0cm9rZVdpZHRoOiB3aWR0aCxcclxuXHRcdFx0c3Ryb2tlTGluZUpvaW46IGxpbmVKb2luLFxyXG5cdFx0XHRzdHJva2VMaW5lQ2FwOiBsaW5lQ2FwLFxyXG5cdFx0XHRzdHJva2VNaXRlckxpbWl0OiBtaXRlckxpbWl0XHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBwb2ludHNUb1N0cm9rZSggcG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSApIHtcclxuXHJcblx0XHQvLyBHZW5lcmF0ZXMgYSBzdHJva2Ugd2l0aCBzb21lIHdpZHRoIGFyb3VuZCB0aGUgZ2l2ZW4gcGF0aC5cclxuXHRcdC8vIFRoZSBwYXRoIGNhbiBiZSBvcGVuIG9yIGNsb3NlZCAobGFzdCBwb2ludCBlcXVhbHMgdG8gZmlyc3QgcG9pbnQpXHJcblx0XHQvLyBQYXJhbSBwb2ludHM6IEFycmF5IG9mIFZlY3RvcjJEICh0aGUgcGF0aCkuIE1pbmltdW0gMiBwb2ludHMuXHJcblx0XHQvLyBQYXJhbSBzdHlsZTogT2JqZWN0IHdpdGggU1ZHIHByb3BlcnRpZXMgYXMgcmV0dXJuZWQgYnkgU1ZHTG9hZGVyLmdldFN0cm9rZVN0eWxlKCksIG9yIFNWR0xvYWRlci5wYXJzZSgpIGluIHRoZSBwYXRoLnVzZXJEYXRhLnN0eWxlIG9iamVjdFxyXG5cdFx0Ly8gUGFyYW1zIGFyY0RpdmlzaW9uczogQXJjIGRpdmlzaW9ucyBmb3Igcm91bmQgam9pbnMgYW5kIGVuZGNhcHMuIChPcHRpb25hbClcclxuXHRcdC8vIFBhcmFtIG1pbkRpc3RhbmNlOiBQb2ludHMgY2xvc2VyIHRvIHRoaXMgZGlzdGFuY2Ugd2lsbCBiZSBtZXJnZWQuIChPcHRpb25hbClcclxuXHRcdC8vIFJldHVybnMgQnVmZmVyR2VvbWV0cnkgd2l0aCBzdHJva2UgdHJpYW5nbGVzIChJbiBwbGFuZSB6ID0gMCkuIFVWIGNvb3JkaW5hdGVzIGFyZSBnZW5lcmF0ZWQgKCd1JyBhbG9uZyBwYXRoLiAndicgYWNyb3NzIGl0LCBmcm9tIGxlZnQgdG8gcmlnaHQpXHJcblxyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuXHRcdGNvbnN0IHV2cyA9IFtdO1xyXG5cclxuXHRcdGlmICggU1ZHTG9hZGVyLnBvaW50c1RvU3Ryb2tlV2l0aEJ1ZmZlcnMoIHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UsIHZlcnRpY2VzLCBub3JtYWxzLCB1dnMgKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIHBvaW50c1RvU3Ryb2tlV2l0aEJ1ZmZlcnMoIHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UsIHZlcnRpY2VzLCBub3JtYWxzLCB1dnMsIHZlcnRleE9mZnNldCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIGV4aXN0aW5nIGFycmF5cyBvciBidWZmZXJzLlxyXG5cdFx0Ly8gQWNjZXB0cyBzYW1lIHBhcmFtZXRlcnMgYXMgcG9pbnRzVG9TdHJva2UsIHBsdXMgdGhlIGJ1ZmZlcnMgYW5kIG9wdGlvbmFsIG9mZnNldC5cclxuXHRcdC8vIFBhcmFtIHZlcnRleE9mZnNldDogT2Zmc2V0IHZlcnRpY2VzIHRvIHN0YXJ0IHdyaXRpbmcgaW4gdGhlIGJ1ZmZlcnMgKDMgZWxlbWVudHMvdmVydGV4IGZvciB2ZXJ0aWNlcyBhbmQgbm9ybWFscywgYW5kIDIgZWxlbWVudHMvdmVydGV4IGZvciB1dnMpXHJcblx0XHQvLyBSZXR1cm5zIG51bWJlciBvZiB3cml0dGVuIHZlcnRpY2VzIC8gbm9ybWFscyAvIHV2cyBwYWlyc1xyXG5cdFx0Ly8gaWYgJ3ZlcnRpY2VzJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG5vIHRyaWFuZ2xlcyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZSByZXR1cm5lZCB2ZXJ0aWNlcyBjb3VudCB3aWxsIHN0aWxsIGJlIHZhbGlkICh1c2VmdWwgdG8gcHJlYWxsb2NhdGUgdGhlIGJ1ZmZlcnMpXHJcblx0XHQvLyAnbm9ybWFscycgYW5kICd1dnMnIGJ1ZmZlcnMgYXJlIG9wdGlvbmFsXHJcblxyXG5cdFx0Y29uc3QgdGVtcFYyXzEgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgdGVtcFYyXzIgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgdGVtcFYyXzMgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgdGVtcFYyXzQgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgdGVtcFYyXzUgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgdGVtcFYyXzYgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgdGVtcFYyXzcgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgbGFzdFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRjb25zdCBsYXN0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdGNvbnN0IHBvaW50MEwgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgcG9pbnQwUiA9IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRjb25zdCBjdXJyZW50UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdGNvbnN0IGN1cnJlbnRQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3QgbmV4dFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRjb25zdCBuZXh0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdGNvbnN0IGlubmVyUG9pbnQgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0Y29uc3Qgb3V0ZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0YXJjRGl2aXNpb25zID0gYXJjRGl2aXNpb25zICE9PSB1bmRlZmluZWQgPyBhcmNEaXZpc2lvbnMgOiAxMjtcclxuXHRcdG1pbkRpc3RhbmNlID0gbWluRGlzdGFuY2UgIT09IHVuZGVmaW5lZCA/IG1pbkRpc3RhbmNlIDogMC4wMDE7XHJcblx0XHR2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhPZmZzZXQgIT09IHVuZGVmaW5lZCA/IHZlcnRleE9mZnNldCA6IDA7XHJcblxyXG5cdFx0Ly8gRmlyc3QgZW5zdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVkIHBvaW50c1xyXG5cdFx0cG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdFx0Y29uc3QgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIG51bVBvaW50cyA8IDIgKSByZXR1cm4gMDtcclxuXHJcblx0XHRjb25zdCBpc0Nsb3NlZCA9IHBvaW50c1sgMCBdLmVxdWFscyggcG9pbnRzWyBudW1Qb2ludHMgLSAxIF0gKTtcclxuXHJcblx0XHRsZXQgY3VycmVudFBvaW50O1xyXG5cdFx0bGV0IHByZXZpb3VzUG9pbnQgPSBwb2ludHNbIDAgXTtcclxuXHRcdGxldCBuZXh0UG9pbnQ7XHJcblxyXG5cdFx0Y29uc3Qgc3Ryb2tlV2lkdGgyID0gc3R5bGUuc3Ryb2tlV2lkdGggLyAyO1xyXG5cclxuXHRcdGNvbnN0IGRlbHRhVSA9IDEgLyAoIG51bVBvaW50cyAtIDEgKTtcclxuXHRcdGxldCB1MCA9IDAsIHUxO1xyXG5cclxuXHRcdGxldCBpbm5lclNpZGVNb2RpZmllZDtcclxuXHRcdGxldCBqb2luSXNPbkxlZnRTaWRlO1xyXG5cdFx0bGV0IGlzTWl0ZXI7XHJcblx0XHRsZXQgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcclxuXHJcblx0XHRsZXQgbnVtVmVydGljZXMgPSAwO1xyXG5cdFx0bGV0IGN1cnJlbnRDb29yZGluYXRlID0gdmVydGV4T2Zmc2V0ICogMztcclxuXHRcdGxldCBjdXJyZW50Q29vcmRpbmF0ZVVWID0gdmVydGV4T2Zmc2V0ICogMjtcclxuXHJcblx0XHQvLyBHZXQgaW5pdGlhbCBsZWZ0IGFuZCByaWdodCBzdHJva2UgcG9pbnRzXHJcblx0XHRnZXROb3JtYWwoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSwgdGVtcFYyXzEgKS5tdWx0aXBseVNjYWxhciggc3Ryb2tlV2lkdGgyICk7XHJcblx0XHRsYXN0UG9pbnRMLmNvcHkoIHBvaW50c1sgMCBdICkuc3ViKCB0ZW1wVjJfMSApO1xyXG5cdFx0bGFzdFBvaW50Ui5jb3B5KCBwb2ludHNbIDAgXSApLmFkZCggdGVtcFYyXzEgKTtcclxuXHRcdHBvaW50MEwuY29weSggbGFzdFBvaW50TCApO1xyXG5cdFx0cG9pbnQwUi5jb3B5KCBsYXN0UG9pbnRSICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGlQb2ludCA9IDE7IGlQb2ludCA8IG51bVBvaW50czsgaVBvaW50ICsrICkge1xyXG5cclxuXHRcdFx0Y3VycmVudFBvaW50ID0gcG9pbnRzWyBpUG9pbnQgXTtcclxuXHJcblx0XHRcdC8vIEdldCBuZXh0IHBvaW50XHJcblx0XHRcdGlmICggaVBvaW50ID09PSBudW1Qb2ludHMgLSAxICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGlzQ2xvc2VkICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFNraXAgZHVwbGljYXRlZCBpbml0aWFsIHBvaW50XHJcblx0XHRcdFx0XHRuZXh0UG9pbnQgPSBwb2ludHNbIDEgXTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIG5leHRQb2ludCA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG5leHRQb2ludCA9IHBvaW50c1sgaVBvaW50ICsgMSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTm9ybWFsIG9mIHByZXZpb3VzIHNlZ21lbnQgaW4gdGVtcFYyXzFcclxuXHRcdFx0Y29uc3Qgbm9ybWFsMSA9IHRlbXBWMl8xO1xyXG5cdFx0XHRnZXROb3JtYWwoIHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbm9ybWFsMSApO1xyXG5cclxuXHRcdFx0dGVtcFYyXzMuY29weSggbm9ybWFsMSApLm11bHRpcGx5U2NhbGFyKCBzdHJva2VXaWR0aDIgKTtcclxuXHRcdFx0Y3VycmVudFBvaW50TC5jb3B5KCBjdXJyZW50UG9pbnQgKS5zdWIoIHRlbXBWMl8zICk7XHJcblx0XHRcdGN1cnJlbnRQb2ludFIuY29weSggY3VycmVudFBvaW50ICkuYWRkKCB0ZW1wVjJfMyApO1xyXG5cclxuXHRcdFx0dTEgPSB1MCArIGRlbHRhVTtcclxuXHJcblx0XHRcdGlubmVyU2lkZU1vZGlmaWVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIG5leHRQb2ludCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBOb3JtYWwgb2YgbmV4dCBzZWdtZW50IGluIHRlbXBWMl8yXHJcblx0XHRcdFx0Z2V0Tm9ybWFsKCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgdGVtcFYyXzIgKTtcclxuXHJcblx0XHRcdFx0dGVtcFYyXzMuY29weSggdGVtcFYyXzIgKS5tdWx0aXBseVNjYWxhciggc3Ryb2tlV2lkdGgyICk7XHJcblx0XHRcdFx0bmV4dFBvaW50TC5jb3B5KCBjdXJyZW50UG9pbnQgKS5zdWIoIHRlbXBWMl8zICk7XHJcblx0XHRcdFx0bmV4dFBvaW50Ui5jb3B5KCBjdXJyZW50UG9pbnQgKS5hZGQoIHRlbXBWMl8zICk7XHJcblxyXG5cdFx0XHRcdGpvaW5Jc09uTGVmdFNpZGUgPSB0cnVlO1xyXG5cdFx0XHRcdHRlbXBWMl8zLnN1YlZlY3RvcnMoIG5leHRQb2ludCwgcHJldmlvdXNQb2ludCApO1xyXG5cdFx0XHRcdGlmICggbm9ybWFsMS5kb3QoIHRlbXBWMl8zICkgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdGpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGlQb2ludCA9PT0gMSApIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlID0gam9pbklzT25MZWZ0U2lkZTtcclxuXHJcblx0XHRcdFx0dGVtcFYyXzMuc3ViVmVjdG9ycyggbmV4dFBvaW50LCBjdXJyZW50UG9pbnQgKTtcclxuXHRcdFx0XHR0ZW1wVjJfMy5ub3JtYWxpemUoKTtcclxuXHRcdFx0XHRjb25zdCBkb3QgPSBNYXRoLmFicyggbm9ybWFsMS5kb3QoIHRlbXBWMl8zICkgKTtcclxuXHJcblx0XHRcdFx0Ly8gSWYgcGF0aCBpcyBzdHJhaWdodCwgZG9uJ3QgY3JlYXRlIGpvaW5cclxuXHRcdFx0XHRpZiAoIGRvdCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIENvbXB1dGUgaW5uZXIgYW5kIG91dGVyIHNlZ21lbnQgaW50ZXJzZWN0aW9uc1xyXG5cdFx0XHRcdFx0Y29uc3QgbWl0ZXJTaWRlID0gc3Ryb2tlV2lkdGgyIC8gZG90O1xyXG5cdFx0XHRcdFx0dGVtcFYyXzMubXVsdGlwbHlTY2FsYXIoIC0gbWl0ZXJTaWRlICk7XHJcblx0XHRcdFx0XHR0ZW1wVjJfNC5zdWJWZWN0b3JzKCBjdXJyZW50UG9pbnQsIHByZXZpb3VzUG9pbnQgKTtcclxuXHRcdFx0XHRcdHRlbXBWMl81LmNvcHkoIHRlbXBWMl80ICkuc2V0TGVuZ3RoKCBtaXRlclNpZGUgKS5hZGQoIHRlbXBWMl8zICk7XHJcblx0XHRcdFx0XHRpbm5lclBvaW50LmNvcHkoIHRlbXBWMl81ICkubmVnYXRlKCk7XHJcblx0XHRcdFx0XHRjb25zdCBtaXRlckxlbmd0aDIgPSB0ZW1wVjJfNS5sZW5ndGgoKTtcclxuXHRcdFx0XHRcdGNvbnN0IHNlZ21lbnRMZW5ndGhQcmV2ID0gdGVtcFYyXzQubGVuZ3RoKCk7XHJcblx0XHRcdFx0XHR0ZW1wVjJfNC5kaXZpZGVTY2FsYXIoIHNlZ21lbnRMZW5ndGhQcmV2ICk7XHJcblx0XHRcdFx0XHR0ZW1wVjJfNi5zdWJWZWN0b3JzKCBuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCApO1xyXG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudExlbmd0aE5leHQgPSB0ZW1wVjJfNi5sZW5ndGgoKTtcclxuXHRcdFx0XHRcdHRlbXBWMl82LmRpdmlkZVNjYWxhciggc2VnbWVudExlbmd0aE5leHQgKTtcclxuXHRcdFx0XHRcdC8vIENoZWNrIHRoYXQgcHJldmlvdXMgYW5kIG5leHQgc2VnbWVudHMgZG9lc24ndCBvdmVybGFwIHdpdGggdGhlIGlubmVyUG9pbnQgb2YgaW50ZXJzZWN0aW9uXHJcblx0XHRcdFx0XHRpZiAoIHRlbXBWMl80LmRvdCggaW5uZXJQb2ludCApIDwgc2VnbWVudExlbmd0aFByZXYgJiYgdGVtcFYyXzYuZG90KCBpbm5lclBvaW50ICkgPCBzZWdtZW50TGVuZ3RoTmV4dCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlubmVyU2lkZU1vZGlmaWVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3V0ZXJQb2ludC5jb3B5KCB0ZW1wVjJfNSApLmFkZCggY3VycmVudFBvaW50ICk7XHJcblx0XHRcdFx0XHRpbm5lclBvaW50LmFkZCggY3VycmVudFBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0aXNNaXRlciA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG5leHRQb2ludFIuY29weSggaW5uZXJQb2ludCApO1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRQb2ludFIuY29weSggaW5uZXJQb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bmV4dFBvaW50TC5jb3B5KCBpbm5lclBvaW50ICk7XHJcblx0XHRcdFx0XHRcdFx0Y3VycmVudFBvaW50TC5jb3B5KCBpbm5lclBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZ2VuZXJhdGVkIGhlcmUgaWYgdGhlcmUgd2FzIG92ZXJsYXBwaW5nXHJcblxyXG5cdFx0XHRcdFx0XHRtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBzdHlsZS5zdHJva2VMaW5lSm9pbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ2JldmVsJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0bWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdTEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdyb3VuZCc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIFNlZ21lbnQgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gSm9pbiB0cmlhbmdsZXNcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBuZXh0UG9pbnRMLCB1MSwgMCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY3VycmVudFBvaW50LCBuZXh0UG9pbnRSLCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWl0ZXInOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtaXRlci1jbGlwJzpcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWl0ZXJGcmFjdGlvbiA9ICggc3Ryb2tlV2lkdGgyICogc3R5bGUuc3Ryb2tlTWl0ZXJMaW1pdCApIC8gbWl0ZXJMZW5ndGgyO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG1pdGVyRnJhY3Rpb24gPCAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBqb2luIG1pdGVyIGxlbmd0aCBleGNlZWRzIHRoZSBtaXRlciBsaW1pdFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggc3R5bGUuc3Ryb2tlTGluZUpvaW4gIT09ICdtaXRlci1jbGlwJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTZWdtZW50IHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gTWl0ZXItY2xpcCBqb2luIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNi5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBjdXJyZW50UG9pbnRMICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIGN1cnJlbnRQb2ludEwgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNy5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBuZXh0UG9pbnRMICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIG5leHRQb2ludEwgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAwICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUxLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNi5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBjdXJyZW50UG9pbnRSICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIGN1cnJlbnRQb2ludFIgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNy5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBuZXh0UG9pbnRSICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIG5leHRQb2ludFIgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDEgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIE1pdGVyIGpvaW4gc2VnbWVudCB0cmlhbmdsZXNcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGlubmVyU2lkZU1vZGlmaWVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW1pemVkIHNlZ21lbnQgKyBqb2luIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0UG9pbnRMLmNvcHkoIG91dGVyUG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRQb2ludFIuY29weSggb3V0ZXJQb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQWRkIGV4dHJhIG1pdGVyIGpvaW4gdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1MSwgMCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlzTWl0ZXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBUaGUgc2VnbWVudCB0cmlhbmdsZXMgYXJlIGdlbmVyYXRlZCBoZXJlIHdoZW4gdHdvIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgY29sbGluZWFyXHJcblxyXG5cdFx0XHRcdFx0bWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBnZW5lcmF0ZWQgaGVyZSBpZiBpdCBpcyB0aGUgZW5kaW5nIHNlZ21lbnRcclxuXHJcblx0XHRcdFx0bWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggISBpc0Nsb3NlZCAmJiBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFN0YXJ0IGxpbmUgZW5kY2FwXHJcblx0XHRcdFx0YWRkQ2FwR2VvbWV0cnkoIHBvaW50c1sgMCBdLCBwb2ludDBMLCBwb2ludDBSLCBqb2luSXNPbkxlZnRTaWRlLCB0cnVlLCB1MCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSW5jcmVtZW50IGxvb3AgdmFyaWFibGVzXHJcblxyXG5cdFx0XHR1MCA9IHUxO1xyXG5cclxuXHRcdFx0cHJldmlvdXNQb2ludCA9IGN1cnJlbnRQb2ludDtcclxuXHJcblx0XHRcdGxhc3RQb2ludEwuY29weSggbmV4dFBvaW50TCApO1xyXG5cdFx0XHRsYXN0UG9pbnRSLmNvcHkoIG5leHRQb2ludFIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIGlzQ2xvc2VkICkge1xyXG5cclxuXHRcdFx0Ly8gRW5kaW5nIGxpbmUgZW5kY2FwXHJcblx0XHRcdGFkZENhcEdlb21ldHJ5KCBjdXJyZW50UG9pbnQsIGN1cnJlbnRQb2ludEwsIGN1cnJlbnRQb2ludFIsIGpvaW5Jc09uTGVmdFNpZGUsIGZhbHNlLCB1MSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGlubmVyU2lkZU1vZGlmaWVkICYmIHZlcnRpY2VzICkge1xyXG5cclxuXHRcdFx0Ly8gTW9kaWZ5IHBhdGggZmlyc3Qgc2VnbWVudCB2ZXJ0aWNlcyB0byBhZGp1c3QgdG8gdGhlIHNlZ21lbnRzIGlubmVyIGFuZCBvdXRlciBpbnRlcnNlY3Rpb25zXHJcblxyXG5cdFx0XHRsZXQgbGFzdE91dGVyID0gb3V0ZXJQb2ludDtcclxuXHRcdFx0bGV0IGxhc3RJbm5lciA9IGlubmVyUG9pbnQ7XHJcblxyXG5cdFx0XHRpZiAoIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlICE9PSBqb2luSXNPbkxlZnRTaWRlICkge1xyXG5cclxuXHRcdFx0XHRsYXN0T3V0ZXIgPSBpbm5lclBvaW50O1xyXG5cdFx0XHRcdGxhc3RJbm5lciA9IG91dGVyUG9pbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaXNNaXRlciB8fCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XHJcblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpc01pdGVyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bGFzdE91dGVyLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpc01pdGVyIHx8ICEgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xyXG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaXNNaXRlciApIHtcclxuXHJcblx0XHRcdFx0XHRcdGxhc3RPdXRlci50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bVZlcnRpY2VzO1xyXG5cclxuXHRcdC8vIC0tIEVuZCBvZiBhbGdvcml0aG1cclxuXHJcblx0XHQvLyAtLSBGdW5jdGlvbnNcclxuXHJcblx0XHRmdW5jdGlvbiBnZXROb3JtYWwoIHAxLCBwMiwgcmVzdWx0ICkge1xyXG5cclxuXHRcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHAyLCBwMSApO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSByZXN1bHQueSwgcmVzdWx0LnggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBwb3NpdGlvbiwgdSwgdiApIHtcclxuXHJcblx0XHRcdGlmICggdmVydGljZXMgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSBdID0gcG9zaXRpb24ueDtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgY3VycmVudENvb3JkaW5hdGUgKyAxIF0gPSBwb3NpdGlvbi55O1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDIgXSA9IDA7XHJcblxyXG5cdFx0XHRcdGlmICggbm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBjdXJyZW50Q29vcmRpbmF0ZSBdID0gMDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGN1cnJlbnRDb29yZGluYXRlICsgMSBdID0gMDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGN1cnJlbnRDb29yZGluYXRlICsgMiBdID0gMTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjdXJyZW50Q29vcmRpbmF0ZSArPSAzO1xyXG5cclxuXHRcdFx0XHRpZiAoIHV2cyApIHtcclxuXHJcblx0XHRcdFx0XHR1dnNbIGN1cnJlbnRDb29yZGluYXRlVVYgXSA9IHU7XHJcblx0XHRcdFx0XHR1dnNbIGN1cnJlbnRDb29yZGluYXRlVVYgKyAxIF0gPSB2O1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRDb29yZGluYXRlVVYgKz0gMjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bnVtVmVydGljZXMgKz0gMztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbWFrZUNpcmN1bGFyU2VjdG9yKCBjZW50ZXIsIHAxLCBwMiwgdSwgdiApIHtcclxuXHJcblx0XHRcdC8vIHBhcmFtIHAxLCBwMjogUG9pbnRzIGluIHRoZSBjaXJjbGUgYXJjLlxyXG5cdFx0XHQvLyBwMSBhbmQgcDIgYXJlIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXHJcblxyXG5cdFx0XHR0ZW1wVjJfMS5jb3B5KCBwMSApLnN1YiggY2VudGVyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHRlbXBWMl8yLmNvcHkoIHAyICkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGxldCBhbmdsZSA9IE1hdGguUEk7XHJcblx0XHRcdGNvbnN0IGRvdCA9IHRlbXBWMl8xLmRvdCggdGVtcFYyXzIgKTtcclxuXHRcdFx0aWYgKCBNYXRoLmFicyggZG90ICkgPCAxICkgYW5nbGUgPSBNYXRoLmFicyggTWF0aC5hY29zKCBkb3QgKSApO1xyXG5cclxuXHRcdFx0YW5nbGUgLz0gYXJjRGl2aXNpb25zO1xyXG5cclxuXHRcdFx0dGVtcFYyXzMuY29weSggcDEgKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhcmNEaXZpc2lvbnMgLSAxOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRlbXBWMl80LmNvcHkoIHRlbXBWMl8zICkucm90YXRlQXJvdW5kKCBjZW50ZXIsIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzMsIHUsIHYgKTtcclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl80LCB1LCB2ICk7XHJcblx0XHRcdFx0YWRkVmVydGV4KCBjZW50ZXIsIHUsIDAuNSApO1xyXG5cclxuXHRcdFx0XHR0ZW1wVjJfMy5jb3B5KCB0ZW1wVjJfNCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNCwgdSwgdiApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIHAyLCB1LCB2ICk7XHJcblx0XHRcdGFkZFZlcnRleCggY2VudGVyLCB1LCAwLjUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbWFrZVNlZ21lbnRUcmlhbmdsZXMoKSB7XHJcblxyXG5cdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XHJcblx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xyXG5cclxuXHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAxICk7XHJcblx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdSApIHtcclxuXHJcblx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIE9wdGltaXplZCBzZWdtZW50ICsgYmV2ZWwgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBQYXRoIHNlZ21lbnRzIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQmV2ZWwgam9pbiB0cmlhbmdsZVxyXG5cclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdSwgMCApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1LCAwICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUsIDAuNSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIFBhdGggc2VnbWVudHMgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xyXG5cclxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBCZXZlbCBqb2luIHRyaWFuZ2xlXHJcblxyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1LCAxICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdSwgMC41ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIEJldmVsIGpvaW4gdHJpYW5nbGUuIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZG9uZSBpbiB0aGUgbWFpbiBsb29wXHJcblxyXG5cdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdSwgMCApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUsIDAuNSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdSwgMSApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1LCAwICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdSwgMC41ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCApIHtcclxuXHJcblx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMSApO1xyXG5cclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTAsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdTAsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XHJcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xyXG5cclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTAsIDEgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XHJcblxyXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcclxuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdTAsIDEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRDYXBHZW9tZXRyeSggY2VudGVyLCBwMSwgcDIsIGpvaW5Jc09uTGVmdFNpZGUsIHN0YXJ0LCB1ICkge1xyXG5cclxuXHRcdFx0Ly8gcGFyYW0gY2VudGVyOiBFbmQgcG9pbnQgb2YgdGhlIHBhdGhcclxuXHRcdFx0Ly8gcGFyYW0gcDEsIHAyOiBMZWZ0IGFuZCByaWdodCBjYXAgcG9pbnRzXHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBzdHlsZS5zdHJva2VMaW5lQ2FwICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdyb3VuZCc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzdGFydCApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY2VudGVyLCBwMiwgcDEsIHUsIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGNlbnRlciwgcDEsIHAyLCB1LCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3NxdWFyZSc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzdGFydCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRlbXBWMl8xLnN1YlZlY3RvcnMoIHAxLCBjZW50ZXIgKTtcclxuXHRcdFx0XHRcdFx0dGVtcFYyXzIuc2V0KCB0ZW1wVjJfMS55LCAtIHRlbXBWMl8xLnggKTtcclxuXHJcblx0XHRcdFx0XHRcdHRlbXBWMl8zLmFkZFZlY3RvcnMoIHRlbXBWMl8xLCB0ZW1wVjJfMiApLmFkZCggY2VudGVyICk7XHJcblx0XHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIHRlbXBWMl8yLCB0ZW1wVjJfMSApLmFkZCggY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBNb2RpZnkgYWxyZWFkeSBleGlzdGluZyB2ZXJ0aWNlc1xyXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xyXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCAwICogMyApO1xyXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XHJcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XHJcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHRlbXBWMl8xLnN1YlZlY3RvcnMoIHAyLCBjZW50ZXIgKTtcclxuXHRcdFx0XHRcdFx0dGVtcFYyXzIuc2V0KCB0ZW1wVjJfMS55LCAtIHRlbXBWMl8xLnggKTtcclxuXHJcblx0XHRcdFx0XHRcdHRlbXBWMl8zLmFkZFZlY3RvcnMoIHRlbXBWMl8xLCB0ZW1wVjJfMiApLmFkZCggY2VudGVyICk7XHJcblx0XHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIHRlbXBWMl8yLCB0ZW1wVjJfMSApLmFkZCggY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB2bCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdC8vIE1vZGlmeSBhbHJlYWR5IGV4aXN0aW5nIHZlcnRpY2VzXHJcblx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIHZsIC0gMSAqIDMgKTtcclxuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSAyICogMyApO1xyXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDQgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfMy50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSAyICogMyApO1xyXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDEgKiAzICk7XHJcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gNCAqIDMgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2J1dHQnOlxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0Ly8gTm90aGluZyB0byBkbyBoZXJlXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyggcG9pbnRzICkge1xyXG5cclxuXHRcdFx0Ly8gQ3JlYXRlcyBhIG5ldyBhcnJheSBpZiBuZWNlc3Nhcnkgd2l0aCBkdXBsaWNhdGVkIHBvaW50cyByZW1vdmVkLlxyXG5cdFx0XHQvLyBUaGlzIGRvZXMgbm90IHJlbW92ZSBkdXBsaWNhdGVkIGluaXRpYWwgYW5kIGVuZGluZyBwb2ludHMgb2YgYSBjbG9zZWQgcGF0aC5cclxuXHJcblx0XHRcdGxldCBkdXBQb2ludHMgPSBmYWxzZTtcclxuXHRcdFx0Zm9yICggbGV0IGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPCBuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBvaW50c1sgaSBdLmRpc3RhbmNlVG8oIHBvaW50c1sgaSArIDEgXSApIDwgbWluRGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZHVwUG9pbnRzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgZHVwUG9pbnRzICkgcmV0dXJuIHBvaW50cztcclxuXHJcblx0XHRcdGNvbnN0IG5ld1BvaW50cyA9IFtdO1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGggLSAxOyBpIDwgbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwb2ludHNbIGkgXS5kaXN0YW5jZVRvKCBwb2ludHNbIGkgKyAxIF0gKSA+PSBtaW5EaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdFx0XHRuZXdQb2ludHMucHVzaCggcG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bmV3UG9pbnRzLnB1c2goIHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ld1BvaW50cztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTVkdMb2FkZXIgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/loaders/SVGLoader.js\n"));

/***/ })

});